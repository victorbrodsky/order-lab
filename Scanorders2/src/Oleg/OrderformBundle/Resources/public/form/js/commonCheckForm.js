/*
 * Copyright (c) 2017 Cornell University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */





//get a block holder by button; this element should contain all form input fields belonging to this button
function getButtonElementParent( btn ) {

    if( btn == null ) {
        return null;
    }

    var parent = btn.closest('.form-element-holder');

    if( orderformtype == "single") {
        if( btn.hasClass('patientmrnbtn') ) {
            var parent = $('#patient_0');
        } else {
            var parent = $('.singlemessage');
        }
    }

    return parent;
}

function checkMultiFormOnNext(nextBtn) {
    $("#next_button_multi").hide();
    $("#optional_button").show();

    //scroll page to message_param
    //var x = $('#message_param').offset().top;
    var x = $(document).height();
    //console.log('x='+x);
    $('html, body').animate( {scrollTop: x}, 250 );
}

//set global auto generated mrn and accession types
function setAutoGeneratedTypes() {

    //no need to set id of autogenerated acc and mrn for show
    if( cycle == "show" ) {
        return;
    }

    //no need to set id of autogenerated acc and mrn for pages without "save on ildetimeout" and without amend buttons
    if( $('#save_order_onidletimeout_btn').length == 0 && $('#scanorder_amend_order_btn').length == 0 ) {
        return;
    }

    //console.log("set Auto Generated Types");
    getKeyTypeID('patient','Auto-generated MRN').
        then(
        function(response) {
            _auto_generated_mrn_type = response;    //now it should be 13
            //console.log("_auto_generated_mrn_type="+_auto_generated_mrn_type);
        }
    );

    getKeyTypeID('accession','Auto-generated Accession Number').
        then(
        function(response) {
            _auto_generated_accession_type = response;  //now it should be 8
            //console.log("_auto_generated_accession_type="+_auto_generated_accession_type);
        }
    );
}

//return id of the keytype by keytype string
//if keytype does not exists in DB, return keytype string
function getKeyTypeID( name, keytype ) {
    return Q.promise(function(resolve, reject) {

        $.ajax({
            url: getCommonBaseUrl("check/"+name+'/keytype/'+keytype),   //urlCheck+name+'/keytype/'+keytype,
            type: 'GET',
            //data: {keytype: keytype},
            contentType: 'application/json',
            dataType: 'json',
            timeout: _ajaxTimeout,
            async: false,
            success: function (data) {
                //console.debug("get element ajax ok");
                if( data && data != '' ) {
                    //console.log(name+": keytype is found. keytype="+data);
                    resolve(data);
                } else {
                    //console.log(name+": keytype is not found.");
                    resolve(keytype);
                }
            },
            error: function ( x, t, m ) {
                //console.debug("keytype id: ajax error "+name);
                if( t === "timeout" ) {
                    getAjaxTimeoutMsg();
                }
                reject(Error("Check Existing Error"));
            }
        });
    }); //promise
}

function cleanValidationAlert() {
    if( cycle == "new" || cycle == "amend" || cycle == "edit" ) {
        $('.validationerror-added').each(function() {
            $(this).remove();
        });
        //$('#validationerror').html('')
        dataquality_message1.length = 0;
        dataquality_message2.length = 0;
    }
}

function initAllElements(newHolder) {

    //console.log('cycle='+cycle);
    if( cycle == "new" ) {

        if( typeof newHolder === 'undefined' || newHolder.length == 0 ) {
            var check_btns = $("[id=check_btn]");
        } else {
            var check_btns = newHolder.find("[id=check_btn]");
        }

        //console.log("check_btns.length="+check_btns.length);
        for (var i = 0; i < check_btns.length; i++) {
            var idArr = check_btns.eq(i).attr("id").split("_");
            if( idArr[2] != "slide" && check_btns.eq(i).attr('flag') != "done" ) {
                check_btns.eq(i).attr('flag', 'done');  //done required to see if the fields belonging to this button was already disabled when adding a new elements on multi forms
                disableInElementBlock(check_btns.eq(i), true, null, "notkey", null);
            }
        }
    }

}


function isKey(element, field) {

    if(
            element.hasClass('keyfield') ||
            element.hasClass('accessiontype-combobox') ||
            element.hasClass('mrntype-combobox')
    ) {
        return true;
    } else {
        return false;
    }

}


function invertButton(btn) {
    //console.log("invert Button: glyphicon class="+btn.find("i").attr("class"));
    if( btn.hasClass('checkbtn') ) {
        //console.log("check=>remove");
        btn.find("i").removeClass('glyphicon-check').addClass('glyphicon-remove');
        btn.removeClass('checkbtn').addClass('removebtn');
    } else {
        //console.log("remove=>check");
        btn.find("i").removeClass('glyphicon-remove').addClass('glyphicon-check');
        btn.removeClass('removebtn').addClass('checkbtn');
    }
    //console.log("finish invert Button: glyphicon class="+btn.attr("class"));
}

//button 'loading' and reset causes to change the class to the original button
function fixCheckRemoveButton(btn) {
    //printF(btn," fix button: ");
    if( btn.hasClass('checkbtn') ) {
        //console.log("fix check");
        btn.find("i").removeClass('glyphicon-remove').addClass('glyphicon-check');
    }
    if( btn.hasClass('removebtn') ) {
        //console.log("fix remove");
        btn.find("i").removeClass('glyphicon-check').addClass('glyphicon-remove');
    }
}

function createErrorWell(inputElement,name,errtext) {
    var errorStr = "";
    if( name == "patient" ) {
        errorStr = 'This is not a previously auto-generated MRN. Please correct the MRN or select "Auto-generated MRN" for a new one.';
    } else
    if( name == "accession" ) {
        errorStr = 'This is not a previously auto-generated accession number. Please correct the accession number or select "Auto-generated Accession Number" for a new one.';
    } else {
        errorStr = 'This is not a previously auto-generated number. Please correct this number or empty this field and click the check box to generate a new one.';
    }

    if( errtext ) {
        errorStr = errtext;
    }

    var errorHtml =
        '<div class="maskerror-added alert alert-danger">' + 
            errorStr +
        '</div>';

    inputElement.after(errorHtml);
    
    return errorHtml;
}

function deleteSuccess(btnObj,single) {
    var btnElement = btnObj.btn;
    //console.log("delete success: "+btnObj);
    //printF(btnElement,"Delete on Success:")
    if( !btnElement ) {
        return false;
    }
    cleanFieldsInElementBlock( btnElement, "all", single ); //single = true
    disableInElementBlock(btnElement, true, null, "notkey", null);
    invertButton(btnElement);
    setDefaultMask(btnObj);
}

function deleteError(btnObj,single) {

    fixCheckRemoveButton(btnObj.btn); //fix button, because btn.button('reset') revert back glyphicon to check button

    if( !single ) {
        //printF(btnElement,"btnElement:");
        //check if all children buttons are not checked == has class removebtn
        var errors = 0;
        var btnElement = btnObj.btn;
        var checkBtns = btnElement.closest('.panel').find('#check_btn');
        //console.log('checkBtns.length='+checkBtns.length);

        checkBtns.each( function() {
            //printF($(this),'check btn=');
            //printF(btnElement,'btnElement=');
            if( $(this).attr('class') != btnElement.attr('class') ) {
                if( $(this).hasClass('removebtn') ) {
                    errors++;
                }
            }
        });

        //console.log('errors='+errors);
        if( errors == 0 ) {
            deleteSuccess(btnElement,single);
            return;
        }

        var childStr = "Child";
        if( btnObj.name == "accession" ) {
            childStr = "Part";
        }
        if( btnObj.name == "part" ) {
            childStr = "Block";
        }
        alert("Can not delete this element. Make sure if " + childStr + " is deleted.");

    }
}

//check if parent has checked sublings with the same key value. Use only for multi form
function checkParent(element,keyValue,inputEl,name,fieldName,extra) {
    //var parentEl = element.parent().parent().parent().parent().parent().parent().parent().parent().parent();
    var parentEl = element.closest('.panel-patient');
    //console.log("checkParent parentEl.id=" + parentEl.attr('id') + ", class="+parentEl.attr('class'));

    //if this patient has already another checked accession, then check current accession is not possible
    //get patient accession buttons
    var retval = 1;

    //console.log("name+fieldName=" + name+fieldName);

    var sublingsKey = parentEl.find('.'+name+fieldName).each(function() {

        //printF($(this),"check sublings keys=");
        var thisInputEl = $(this).find('input.keyfield');

        //ignore if this element is the same as source element: use id
        //console.log("compare: " + thisInputEl.attr('id') + "==" + inputEl.attr('id'));
        if( thisInputEl.attr('id') == inputEl.attr('id') ) {
            //console.log('the same element!!! => return');
            return; //continue
        }

        var keyField = $(this).find('.keyfield');

        if( keyField.hasClass('select2') ) {
            var sublingsKeyValue = keyField.val();
        } else {
            var sublingsKeyValue = keyField.select2("val");
        }

        if( name == "accession" || name == "patient" ) {
            var keytype = $(this).find('.combobox ').not("*[id^='s2id_']").select2('val');
            var sublingsKeyValue = $(this).find('.keyfield ').val();
        }

        //console.log("checkParent sublingsKeyValue=" + sublingsKeyValue + ", keyValue="+keyValue + ", keytype="+keytype+", extra="+extra);

        var cleankeyValue = trimWithCheck(keyValue);
        var cleansublingsKeyValue = trimWithCheck(sublingsKeyValue);

        var sameValue = false;
        if( cleansublingsKeyValue != "" && cleankeyValue != "" ) {
            if( cleansublingsKeyValue.toLowerCase() == cleankeyValue.toLowerCase() ) {
                sameValue = true;
            }
        }

        if( $(this).find('#check_btn').hasClass('removebtn') && sameValue && keytype == extra ) {
            alert("This keyfield "+cleankeyValue+" is already in use and it is checked");
            retval = 0;
            return false;   //break each
        }

        if( sameValue && keytype == extra ) {
            alert("This keyfield " + cleankeyValue + " is already in use");
            retval = 0;
            return false;   //break each
        }

    });

    if( retval == 0 ) {
        return 0;
    }
    return 1;
}

//element: accession button
//set Patient by data from accession check
function setPatient( btn, keyvalue, extraid, single ) {

    var btnObj = new btnObject(btn,'full'); //'full' => get parent for accession too
    var parentBtnObj = new btnObject(btnObj.parentbtn);
    var parentKey = null;

    if( !parentBtnObj || !btnObj.parentbtn || keyvalue == '' ) {
        console.log("WARNING: Parent (here Patient) does not exists");
        return 0;
    }

    parentKey = trimWithCheck(parentBtnObj.key);

    //check if parent has the same key and type combination
    if( keyvalue == parentKey && extraid == parentBtnObj.type ) {
        return 1;
    }

    //parent has different key type combination and button is check
    if( !parentBtnObj.remove && parentKey && parentBtnObj.type && !(keyvalue == parentKey && extraid == parentBtnObj.type) ) {
        var r=confirm('Different MRN '+ parentKey +' is already set in this form. Are you sure that you want to change the patient?');
        if( r == true ) {
            //console.log("you decide to continue");
        } else {
            //console.log("you canceled");
            return 0;
        }
    }

    //Button is removed and key and type combination is different
    if( parentBtnObj.remove && parentKey && parentBtnObj.type && !(keyvalue == parentKey && extraid == parentBtnObj.type) ) {
        var r=confirm('Patient with MRN '+ parentKey +' is already set in this form. Are you sure that you want to change the patient?');
        if( r == true ) {
            //console.log("you decide to continue");
        } else {
            //console.log("you canceled");
            return 0;
        }
    }

    //if parent key field is already checked: clean it first
    if( parentBtnObj.remove ) {
        //console.log("parent key field is already checked: clean it first");
        //parentBtnObj.btn.trigger("click");

        checkForm( parentBtnObj.btn ).
            then(
            function(response) {
                //console.log("Success!", response);
                return setAndClickPatient();
            }
        ).
            then(
            function(response) {
                //console.log("Chaining with parent OK:", response);
            },
            function(error) {
                console.error("Set Patient by Accession Failed!", error);
            }
        );

    } else {
        return setAndClickPatient();
    }

    function setAndClickPatient() {
        var mrnArr = new Array();
        mrnArr['text'] = keyvalue;
        mrnArr['keytype'] = extraid;
        var keytypeElement = parentBtnObj.btn.closest('.row').find('.combobox').not("*[id^='s2id_']");
        setKeyGroup( keytypeElement, mrnArr );
        //console.log("trig ger parent key button");
        parentBtnObj.btn.trigger("click");

        return 1;
    }

}

//calculate patient age (at the time of encounter)
//listen for dob and encounter date changes, do not override age
function setPatientAndEncounterAgeListener() {

    //console.log("setPatientAndEncounterAgeListener set!");

    $('.encounterage-field').on("change", function(e) {
        //printF($(this),"listener: ");

        //clear warning message
        var encounterAgeEl = $(this).closest('.form-element-holder').find('.encounterage-field');
        if( orderformtype == "single") {
            encounterAgeEl = $(this).closest('.singlemessage').find('.encounterage-field');
        }
        removeAgeConflictWarningMessage(encounterAgeEl);

        //check for age conflict
        checkDobEncdateEncageConflict( $(this) );
    });

    $('.encounter-dob-date, .encounter-date').on("change", function(e) {

        //printF($(this),"listener: ");

        //clear warning message
        var encounterAgeEl = $(this).closest('.panel-patient').find('.encounterage-field');
        if( orderformtype == "single") {
            encounterAgeEl = $('.singlemessage').find('.encounterage-field');
        }
        removeAgeConflictWarningMessage(encounterAgeEl);

        //patient's dob
        if( $(this).hasClass('patient-dob-date') ) {

            var patientdobValue = $(this).val();
            //console.log('patientdobValue='+patientdobValue);

            //set patient's age
            if( patientdobValue != "" ) {
                var patientAgeEl = $(this).closest('.form-element-holder').find('.patientage').find('.not-mapped-simplefield');
                if( orderformtype == "single") {
                    patientAgeEl = $('.singlemessage').find('.patientage').find('.not-mapped-simplefield');
                }
                var age = getAge(patientdobValue);
                if( age > 0 ) {
                    patientAgeEl.html(getAge(patientdobValue));
                } else {
                    patientAgeEl.html("");
                }

            }

            //find all children encounter's encounter date
            var procEncDates = $(this).closest('.panel-patient').find(".encounter-date:not([readonly='readonly']):not([disabled='disabled'])");
            if( orderformtype == "single") {
                procEncDates = $('.singlemessage').find(".encounter-date:not([readonly='readonly']):not([disabled='disabled'])");
            }

            procEncDates.each( function() {

                var encdateValue = $(this).val();
                //console.log('patdob: patientdobValue='+patientdobValue+', encdateValue='+encdateValue);

                //set encounter's age
                if( patientdobValue != "" && encdateValue != "" ) {

                    var age = getAgeByDiff(patientdobValue,encdateValue);
                    //console.log('patientdob: age='+age);

                    //find encounter age element
                    var encounterAgeEl = $(this).closest('.form-element-holder').find('.encounterage-field');
                    if( orderformtype == "single") {
                        encounterAgeEl = $('.singlemessage').find('.encounterage-field');
                    }

                    if( encounterAgeEl.val() == "" ) {  //don't override age
                        encounterAgeEl.val(age);    //when age is set, then  check DobEncdateEncage Conflict will be triggered by encounter age listener
                    } else {
                        checkDobEncdateEncageConflict( $(this) );
                    }

                }

            });
        }

        //encounter encounter date
        if( $(this).hasClass('encounter-date') ) {

            //find patient dob element
            var patientdob = $(this).closest('.panel-patient').find('.form-element-holder').find('.patient-dob-date');
            if( orderformtype == "single") {
                patientdob = $('.singlemessage').find('.patient-dob-date');
            }
            //printF(patientdob,"patientdob: ");

            var patientdobValue = patientdob.val();
            var encdateValue = $(this).val();
            //console.log('encdate: patientdobValue='+patientdobValue+', encdateValue='+encdateValue);

            //set age
            if( patientdobValue != "" && encdateValue != "" ) {

                var age = getAgeByDiff(patientdobValue,encdateValue);
                //console.log('encounterdate: age='+age);

                //find encounter age element
                var encounterAgeEl = $(this).closest('.form-element-holder').find('.encounterage-field');
                if( orderformtype == "single") {
                    encounterAgeEl = $('.singlemessage').find('.encounterage-field');
                }

                if( encounterAgeEl.val() == "" ) {  //don't override age
                    encounterAgeEl.val(age);   //when age is set, then  check DobEncdateEncage Conflict will be triggered by encounter age listener
                } else {
                    checkDobEncdateEncageConflict( $(this) );
                }

            }

        }

    });

    //element: any element from encounter object
    function checkDobEncdateEncageConflict( encounterElement ) {

        //find patient dob element
        var patientdob = encounterElement.closest('.panel-patient').find('.form-element-holder').find('.patient-dob-date');
        if( orderformtype == "single" ) {
            patientdob = $('.singlemessage').find('.patient-dob-date');
        }
        var patientdobValue = patientdob.val();


        //find encounter date element
        var encdate = encounterElement.closest('.panel-patient').find('.form-element-holder').find('.encounter-date');
        if( orderformtype == "single" ) {
            encdate = $('.singlemessage').find('.encounter-date');
        }
        var encdateValue = encdate.val();

        //find encounter age element
        var encage = encounterElement.closest('.panel-patient').find('.form-element-holder').find('.encounterage-field');
        if( orderformtype == "single" ) {
            encage = $('.singlemessage').find('.encounterage-field');
        }
        var encageValue = encage.val();

        //console.log('check: patientdobValue='+patientdobValue+', encdateValue='+encdateValue+", encageValue="+encageValue);

        //Case 1a: if patientdobValue and encdateValue are empty => no conflict
        if( patientdobValue == "" && encdateValue == "" ) {
            return;
        }

        //Case 1b: if encageValue is empty => no conflict
        if( encageValue == "" ) {
            return;
        }

        //Case 1c: if patientdobValue is empty => no conflict
        if( patientdobValue == "" ) {
            return;
        }

        //Case 2: if encounter date is empty, but age and dob are set, verify encounter age with patient age by current date
        if( encdateValue == "" && patientdobValue != "" && encageValue != "" ) {
            var dobage = getAge(patientdobValue);
            //console.log('check: parseInt(encageValue)='+parseInt(encageValue)+', parseInt(dobage)='+parseInt(dobage));
            if( parseInt(encageValue) != parseInt(dobage) ) {
                var msg = "The patient's age at the time of encounter does not correspond to the patient's date of birth (DOB) based on today's date. Please verify and correct the DOB and Patient's Age (at the time of encounter) field values.";
                setAgeConflictWarningMessage(encage,msg,parseInt(dobage));
            }
        }

        //Case 3: all 3 parameters are set: patient's dob, encounter date and age at the time of encounter => the sum of enc age and years from enc must be equal to patient's age
        if( encdateValue != "" && patientdobValue != "" && encageValue != "" ) {
            var encounterage = getAge(encdateValue);
            var dobage = getAge(patientdobValue);
            var expectedAge = getAgeByDiff(patientdobValue,encdateValue);
            //console.log('check: dobage='+dobage+', encounterage='+encounterage+", encageValue="+encageValue+", expectedAge="+expectedAge);
            if( parseInt(encageValue) != expectedAge ) {
                var msg = "The patient's age at the time of encounter does not correspond the patient's date of birth (DOB). Please verify and correct the DOB, Encounter Date, and Patient's Age (at the time of encounter) field values.";
                setAgeConflictWarningMessage(encage,msg,expectedAge);
            }
        }


    }

    function setAgeConflictWarningMessage(encounterAgeEl,msg,expectedAge) {
        //set if not existed
        var warningmsg = encounterAgeEl.parent().find('.age-conflict-added');
        if( warningmsg.length > 0 ) {
            return;
        }
        var errorHtml = '<div class="age-conflict-added alert alert-warning">' +
                        msg +
                        '<p><button type="button" onclick="autoCorrectencounterAge(this,'+expectedAge+')">Auto-correct the age at the time of the encounter</button></p>' +
                        '</div>';
        encounterAgeEl.after(errorHtml);
    }

}

function removeAgeConflictWarningMessage(encounterAgeEl) {
    //printF(encounterAgeEl,"cleanning:");
    var warningmsg = encounterAgeEl.parent().find('.age-conflict-added');
    warningmsg.remove();
}

function autoCorrectencounterAge(msgEl,expectedAge) {
    var encounterAgeEl = $(msgEl).closest('.encounterpatage').find('.encounterage-field');
    //printF(encounterAgeEl,"auto correct procedcure expectedAge="+expectedAge+", :");
    removeAgeConflictWarningMessage(encounterAgeEl);
    encounterAgeEl.val(expectedAge);
}

//use this function to set encounter age when clicking accession check button. Currently not used.
function calculateAgeByDob( btn ) {
    var accessionBtnObj = new btnObject(btn,'full');
    //console.log("accessionBtnObj.name="+accessionBtnObj.name);

    if( accessionBtnObj.name != 'accession' ) {
        return;
    }

    var patientBtnObj = accessionBtnObj.parentbtn;
    //console.log("par btn name="+patientBtnObj.name);

    var patientEl = getButtonElementParent(patientBtnObj);
    //console.log(patientEl);
    var dob = patientEl.find('.patient-dob-date');
    var dobValue = dob.val();
    //console.log("dobValue="+dobValue);

    var encounterEl = getButtonElementParent(btn);
    //console.log(encounterEl);
    var ageEl = encounterEl.find('.encounterage-field');

    //var dobDate = new Date(dobValue);
    var curAge = getAge(dobValue);
    //console.log("curAge=("+curAge+")");

    ageEl.val(curAge);
}

function getAge(dob) {
    var today = new Date();
    var birthDate = new Date(dob);
    var age = today.getFullYear() - birthDate.getFullYear();
    var m = today.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
    }
    return age;
}

function getAgeByDiff(dob,date) {
    var today = new Date(date);
    var birthDate = new Date(dob);
    var age = today.getFullYear() - birthDate.getFullYear();
    var m = today.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
    }
    return age;
}

/////////////////////// validtion related functions /////////////////////////
function validateForm() {

    //console.log("validateForm enter");
    //return false;

    var saveClick = $("#save_order_onidletimeout_btn").attr('clicked');
    //console.log("saveClick="+ saveClick);

    var checkExisting = checkExistingKey("accession");
    //console.log( "accession checkExisting="+checkExisting);
    if( !checkExisting ) {
        if( orderformtype == "single") {
            if( saveClick == 'true' ) {
                //console.log( " single accession existing error => logout without saving");
                idlelogout();   //we have errors on the form, so logout without saving form
            }
            //console.log( "WARNING SINGLE RETURN: checkExisting="+checkExisting);
            return false;
        }
        //existingErrors++;
    }

    var checkExisting = checkExistingKey("patient");
    if( !checkExisting ) {
//        return false;
        //existingErrors++;
    }

    //check "Specify Another Specimen ID / Patient ID Issuer" is not set
    checkSpecifyAnotherIssuer("accession");
    checkSpecifyAnotherIssuer("patient");


    if( $('.maskerror-added').length > 0 ) {
        if( saveClick == 'true' ) {
            //console.log( " mrn existing error => logout without saving");
            idlelogout();   //we have errors on the form, so logout without saving form
        }
        //console.log( "WARNING RETURN 1: maskerror-added.length="+$('.maskerror-added').length);
        return false;
    }

    var checkMrnAcc = checkMrnAccessionConflict();
    //console.log( "checkMrnAcc="+checkMrnAcc);
    if( !checkMrnAcc ) {
        if( saveClick == 'true' ) {
            //console.log( " mrn-accession conflict => logout without saving");
            idlelogout();   //we have errors on the form, so logout without saving form
        }
        //console.log( "WARNING RETURN: checkMrnAcc="+checkMrnAcc);
        return false;
    }

    //console.log("validateForm: error length="+$('.maskerror-added').length);

    if( $('.maskerror-added').length > 0 ) {
        if( saveClick == 'true' ) {
            //console.log( $('.maskerror-added').length+ " error(s) => logout without saving");
            idlelogout();   //we have errors on the form, so logout without saving form
        }
        //console.log( "WARNING RETURN 2: maskerror-added.length="+$('.maskerror-added').length);
        return false;
    }

    //return false; //testing
    return true;
}


//accesion-MRN link validation when the user clicks "Submit" on multi-slide form
function checkMrnAccessionConflict() {

    var totalError = 0;

    if( validateMaskFields() > 0 ) {
        return false;
    }

    //check if conflict was handled by a choice, otherwise, do validation again.
    if( checkIfMrnAccConflictHandled() ) {
        return true;
    }

    if( orderformtype == "single") {
        var accessions = $('#accession-single').find('.keyfield');
        //console.log("singleform");
    } else {
        var accessions = $('.accessionaccession').find('.keyfield');
        //console.log("not singleform");
    }

    //console.log("accessions.length="+accessions.length + ", first id=" + accessions.first().attr('id') + ", class=" + accessions.first().attr('class') );
    //var prototype = $('#form-prototype-data').data('prototype-dataquality');
    //console.log("prototype="+prototype);
    var index = 0;

    //for all accession fields
    accessions.each(function() {

        var accInput = $(this);
        var accValue = accInput.val();

        //var acctypeField = accInput.closest('.row').find('.accessiontype-combobox').not("*[id^='s2id_']").first();
        var acctypeField = getKeyGroupParent(accInput).find('.accessiontype-combobox').not("*[id^='s2id_']").first();

        var acctypeValue = acctypeField.select2("val");
        var acctypeText = acctypeField.select2("data").text;

        if( orderformtype == "single") {
            var mrnHolder = $('#optional_param').find(".patientmrn");
        } else {
            var mrnHolder = accInput.closest('.panel-patient').find(".patientmrn");
        }

        var patientInput = mrnHolder.find('.keyfield').not("*[id^='s2id_']").first();
        var mrnValue = patientInput.val();
        //console.log("patientInput.first().id=" + patientInput.first().attr('id') + ", class=" + patientInput.first().attr('class'));

        var patientMrnInputs = mrnHolder.find('.mrntype-combobox').not("*[id^='s2id_']").first();
        //var mrntypeValue = patientMrnInputs.select2("val");
        var mrntypeValue = patientMrnInputs.select2("val");
        var mrntypeData = patientMrnInputs.select2("data");
        //console.log("sel id="+mrntypeData.id);
        var mrntypeText = mrntypeData.text;
        //console.log("patientInput.last().id=" + patientInput.last().attr('id') + ", class=" + patientInput.last().attr('class'));

        //console.log("accValue="+accValue + ", acctypeValue=" + acctypeValue + "; mrnValue="+mrnValue+", mrntypeValue="+mrntypeValue  );

        if(
            accValue && accValue !="" && acctypeValue && acctypeValue !="" &&
                mrnValue && mrnValue !="" && mrntypeValue && mrntypeValue !=""
        )
        {
            //console.log("validate accession-mrn-mrntype");

//            var mrn = "";
//            var mrntype = "";
//            var provider = "";
//            var date = "";

            accValue = trimWithCheck(accValue);
            acctypeValue = trimWithCheck(acctypeValue);
            var inst = $('.combobox-institution').select2('val');

            $.ajax({
                url: getCommonBaseUrl("check/"+"accession/check"),    //urlCheck+"accession/check",
                type: 'GET',
                data: {key: accValue, extra: acctypeValue, inst: inst},
                contentType: 'application/json',
                dataType: 'json',
                timeout: _ajaxTimeout,
                async: false,
                success: function (data) {
                    //console.debug("get accession ajax ok");

//                    if( data == -1 ) {
//                        //object exists but no permission to see it (not an author or not pathology role)
//                        totalError++;
//                        return false;
//                    }

                    if( data == -2 ) {
                        //Existing Auto-generated object does not exist in DB
                        var errorHtml = createErrorWell(accInput,"accession");
                        $('#validationerror').append(errorHtml);
                        return false;
                    }

                    if( data.id ) {

                        var mrn = data['parent'];
                        var mrntype = data['extraid'];
                        var mrnstring = data['mrnstring'];
                        var message = data['message'];

                        mrn = trimWithCheck(mrn);
                        mrntype = trimWithCheck(mrntype);
                        mrnValue = trimWithCheck(mrnValue);
                        mrntypeValue = trimWithCheck(mrntypeValue);

                        //console.log('mrn='+mrn+', mrntype='+mrntype);
                        if( mrn == "" && mrntype == "" ) {
                            //console.log("validated successfully !");
                        } else
                        if( mrn == mrnValue && ( mrntype == mrntypeValue || _auto_generated_mrn_type == mrntypeValue ) ) {    //_auto_generated_mrn_type - Auto-generated MRN type ID. Need it for edit or amend form
                            //console.log("validated successfully !");
                        } else {
                            //console.log('mrn='+mrn+', mrntype='+mrntype+ " do not match to form's "+" mrnValue="+mrnValue+", mrntypeValue="+mrntypeValue);

                            var mrnObj = Array();
                            mrnObj["mrnValueForm"] = mrnValue;
                            mrnObj["mrnValueDB"] = mrn;
                            mrnObj["mrntypeIDForm"] = mrntypeValue;
                            mrnObj["mrntypeTextForm"] = mrntypeText;
                            mrnObj["mrnstring"] = mrnstring;
                            mrnObj["patientInput"] = patientInput;

                            var accObj = Array();
                            accObj["accValueForm"] = accValue;
                            accObj["accValueDB"] = null;
                            accObj["acctypeTextForm"] = acctypeText;
                            accObj["acctypeIDForm"] = acctypeValue;
                            accObj["accInput"] = accInput;

                            createDataquality( mrnObj, accObj, message, index );

                            index++;
                            totalError++;

                            //console.log('end of conflict process');
                        }//if

                    } else {
                        console.debug("validation: accession object not found");
                    }
                },
                error: function ( x, t, m ) {
                    console.debug("validation: get object ajax error accession");
                    if( t === "timeout" ) {
                        getAjaxTimeoutMsg();
                    }
                    return false;
                }
            });

        }

    });

    //console.log("totalError="+totalError);
    //return false; //testing

    if( totalError == 0 ) {
        return true;
    } else {
        return false;
    }

}

function checkIfMrnAccConflictHandled() {

    //Initial check: get total number of checkboxes
    var totalcheckboxes = 0;

    var reruncount = 0;

    //console.log( "dataquality_message1[0]="+dataquality_message1[0] );
    //console.log( "dataquality_message2[0]="+dataquality_message2[0] );

    var countErrorBoxes = 0;

    var errorBoxes = $('#validationerror').find('.validationerror-added');
    //console.log("errorBoxes.length="+errorBoxes.length);

    for (var i = 0; i < errorBoxes.length; i++) {

        var errorBox = errorBoxes.eq(i);

        var checkedEl = errorBox.find("input:checked");
        //console.log("checkedEl="+checkedEl.val()+", id="+checkedEl.attr("id")+", class="+checkedEl.attr("class"));

        var checkedVal = checkedEl.val();
        //console.log("value="+checkedVal);

        if( checkedEl.is(":checked") ){
            //console.log("checked value="+checkedVal);
            if( checkedVal == "OPTION3" ) {
                reruncount++;
            }
            if( checkedVal == "OPTION1" ) {
                setDataqualityMessage( countErrorBoxes, dataquality_message1[countErrorBoxes] );
            }
            if( checkedVal == "OPTION2" ) {
                setDataqualityMessage( countErrorBoxes, dataquality_message2[countErrorBoxes] );
            }
        } else {
            //alert("Please select one of these options.");
        }
        totalcheckboxes++;

        countErrorBoxes++;

    }

    //clear array
    dataquality_message1.length = 0;
    dataquality_message2.length = 0;

    //console.log("totalcheckboxes="+totalcheckboxes+",reruncount="+reruncount);


    if( totalcheckboxes == 0 ) {
        //continue
        //console.log("totalcheckboxes is zero");
//    } else if( totalcheckboxes != 0 && totalcheckboxes == reruncount ) {    //all error boxes have third option checked
//        cleanValidationAlert();
    } else if( totalcheckboxes > 0 && reruncount > 0 ) { //submit was already pressed before and the third option is checked
        //console.log("conflict is not handled => clean validation alerts");
        cleanValidationAlert();
    } else {    //return true;
        //console.log("conflict handled => return true");
        //return false; //testing
        return true;
    }

    //validate form again
    //console.log("validate form again => return false");
    return false;
}

//create MRN-ACC conflict questions and highlight by red the error fields
function createDataquality( mrnObj, accObj, message, index ) {   //mrnValueForm, mrnValueDB, mrntypeTextForm, accValueForm, accValueDB, acctypeTextForm, mrnstring, message ) {

    var prototype = $('#form-prototype-data').data('prototype-dataquality');
    //console.log("prototype="+prototype);

    var nl = "\n";    //"&#13;&#10;";

    var mrnValueForm = mrnObj["mrnValueForm"];
    var mrnValueDB = mrnObj["mrnValueDB"];
    var mrntypeIDForm = mrnObj["mrntypeIDForm"];
    var mrntypeTextForm = mrnObj["mrntypeTextForm"];
    var mrnstring = mrnObj["mrnstring"];
    var patientInput = mrnObj["patientInput"];

    var accValueForm = accObj["accValueForm"];
    var accValueDB = accObj["accValueDB"];
    var acctypeTextForm = accObj["acctypeTextForm"];
    var acctypeIDForm = accObj["acctypeIDForm"];
    var accInput = accObj["accInput"];

    //console.log("create data quality: mrnValueForm="+mrnValueForm+", mrnValueDB="+mrnValueDB+", accValueForm="+accValueForm+", accValueDB="+accValueDB);

    var message_short = "MRN-ACCESSION CONFLICT:"+nl+"Entered Accession Number "+accValueForm+" ["+acctypeTextForm+"] belongs to Patient with "+mrnstring+", not to Patient with MRN "
        +mrnValueForm+" ["+mrntypeTextForm+"] as you have entered.";
    var message = message_short + " Please correct either the MRN or the Accession Number above.";


    var message1 = "If you believe MRN "+mrnValueForm+" and MRN "+mrnValueDB + " belong to the same patient, please mark here:";
    var dataquality_message_1 = message_short+nl+"I believe "+mrnstring+" and MRN "+mrnValueForm+" ["+mrntypeTextForm+"] belong to the same patient";
    dataquality_message1.push(dataquality_message_1);

    var message2 = "If you believe Accession Number "+accValueForm+" belongs to patient MRN "+mrnValueForm+" and not patient MRN "+mrnValueDB+" (as stated by "+message+"), please mark here:";
    var dataquality_message_2 = message_short+nl+"I believe Accession Number "+accValueForm+" belongs to patient MRN "+mrnValueForm+" ["+mrntypeTextForm+"] and not patient "+mrnstring+" (as stated by "+message+")";
    dataquality_message2.push(dataquality_message_2);

    var message3 = "If you have changed the involved MRN "+mrnValueForm+" or the Accession Number "+accValueForm+" in the form above, please mark here:";

    if( !prototype ) {
        //console.log('WARNING: conflict prototype is not found!!!');
        return false;
    }

    var newForm = prototype.replace(/__dataqualitymrnacc__/g, index);

    newForm = newForm.replace("MRN-ACCESSION CONFLICT", message);

    newForm = newForm.replace("TEXT1", message1);
    newForm = newForm.replace("TEXT2", message2);
    newForm = newForm.replace("TEXT3", message3);

    //console.log("newForm="+newForm);

    var newElementsAppended = $('#validationerror').append(newForm);
    //var newElementsAppended = newForm.appendTo("#validationerror");

    //red
    if( accInput && patientInput ) {
        accInput.parent().addClass("has-error");
        patientInput.parent().addClass("has-error");
    }

    setDataqualityData( index, accValueForm, acctypeIDForm, mrnValueForm, mrntypeIDForm );
}

function setDataqualityMessage(index,message) {
    var partid = "#oleg_orderformbundle_messagetype_conflicts_"+index+"_";
    //console.log("message=" + message);
    $(partid+'description').val(message);
}


function setDataqualityData( index, accession, acctype, mrn, mrntype ) {
    var partid = "#oleg_orderformbundle_messagetype_conflicts_"+index+"_";
    //console.log("set Dataquality Data: "+accession + " " + acctype + " " + mrn + " " + mrntype);
    $(partid+'accession').val(accession);
    $(partid+'accessiontype').val(acctype);
    $(partid+'mrn').val(mrn);
    $(partid+'mrntype').val(mrntype);
}

function checkExistingKey(name) {

    if( orderformtype == "single") {
        if( name == 'accession' ) {
            //var elements = $('#accession-single').find('.keyfield');
            var elements = $('.btn.btn-default.accessionbtn');
        }
        if( name == 'patient' ) {
            //var elements = $('.patientmrn').find('.keyfield');
            var elements = $('.btn.btn-default.patientmrnbtn');
        }
    } else {
        if( name == 'accession' ) {
            //var elements = $('.accessionaccession').find('.keyfield');
            var elements = $('.btn.btn-default.accessionaccessionbtn');
        }
        if( name == 'patient' ) {
            var elements = $('.btn.btn-default.patientmrnbtn');
        }
    }

    var len = elements.length;
    //console.log("len="+len);
    if( len == 0 ) {
        return false;
    }

    //for all accession or mrn buttons
    elements.each(function() {

        var elInput = $(this);
        //printF(elInput,"elInput element:");

        if( orderformtype == "single") {
            var single = true;
        } else {
            var single = false;
        }

        //var keyElement = findKeyElement(elInput, false);
        var keyElement = new btnObject(elInput);

        if( !keyElement || !keyElement.element ) {
            return false;
        }

        var elValue = keyElement.key;
        var eltypeValue = keyElement.type;
        var eltypeValueText = keyElement.typename;

        //printF(elInput,"input element:");
        //console.log("elValue="+elValue + ", eltypeValue=" + eltypeValue );

        //check if patient or accession has the same key field value repeated in the entire form
        if( name == 'patient' || name == 'accession' ) {
            $('.maskerror-added').remove();
            if( ifExistsSameSiblingsInForm(keyElement) ) {
                var errMsg = 'Error: repeated '+name+' key ' + keyElement.key;
                //alert(errMsg);
                var errorHtml = createErrorWell(keyElement.element,null,errMsg);
                $('#validationerror').append(errorHtml);
                return false;
            }
        }
        //testing
        return false;

        if(
            elValue && elValue != "" && eltypeValueText && eltypeValueText.indexOf("Existing Auto-generated") != -1
        )
        {

            elValue = trimWithCheck(elValue);
            eltypeValue = trimWithCheck(eltypeValue);
            var inst = $('.combobox-institution').select2('val');

            $.ajax({
                url: getCommonBaseUrl("check/"+name+'/check'),   //urlCheck+name+'/check',
                type: 'GET',
                data: {key: elValue, extra: eltypeValue, inst: inst},
                contentType: 'application/json',
                dataType: 'json',
                timeout: _ajaxTimeout,
                async: false,
                success: function (data) {
                    //console.debug("get element ajax ok");
                    if( data == -2 ) {
                        var errorHtml = createErrorWell(keyElement.element,name);
                        $('#validationerror').append(errorHtml);
                        return false;
                    }
                },
                error: function ( x, t, m ) {
                    console.debug("validation: get object ajax error "+name);
                    if( t === "timeout" ) {
                        getAjaxTimeoutMsg();
                    }
                    return false;
                }
            });

        }
    });

    //return false;
    return true;
}

function ifExistsSameSiblingsInForm( keyObj ) {
    var key = keyObj.key;
    var type = keyObj.type;
    var name = keyObj.name;
    var fieldname = keyObj.fieldname;
    //console.log("key="+key+", type="+type+", name="+name+", fieldname="+fieldname);

    var exist = false;

    $('#scanorderform').find('.'+name+fieldname).each( function(){
        var btnEl = $(this).find('.btn.'+name+fieldname+'btn');
        //printF(btnEl,"btnEl:");
        //console.log(btnEl);
        var btnObj = new btnObject(btnEl);
        //console.log(btnObj);

        //continue if the same object
        if( keyObj.element.attr('id') == btnObj.element.attr('id') ) {
            return;
        }

        if( key != "" && btnObj.key != "" ) {
            if( key == btnObj.key && type == btnObj.type ) {
                exist = true;
            }
        }

    });

    return exist;
}

function checkSpecifyAnotherIssuer( name ) {


    if( name == 'accession' ) {
        var elements = $('input.accessiontype-combobox');
        var errtext = "Please type in the name of the Specimen ID Issuer above";
    }
    if( name == 'patient' ) {
        var elements = $('input.mrntype-combobox');
        var errtext = "Please type in the name of the Patient ID Issuer above";
    }


    var len = elements.length;
    //console.log("len="+len);
    if( len == 0 ) {
        return false;
    }

    //for all accession or mrn buttons
    elements.each(function() {

        //var elInput = $(this);

        var keytypeText = $(this).select2('data').text;
        //console.log('keytypeText='+keytypeText);

        if( keytypeText == 'Specify Another Specimen ID Issuer' || keytypeText == 'Specify Another Patient ID Issuer' ) {

            //console.log('error: Specify Another is set!');
            var errorHtml = createErrorWell( $(this), name, errtext );
            $('#validationerror').append(errorHtml);

        }

    });


    //return true;
    return false;
}

////////////////////// end of validtion related functions //////////////////////

//process exception fields such as patient's DOB and Clinical Summary to be unlocked if they are empty
function processExceptionalFields(btnObj) {

    //console.log('btnObj.name='+btnObj.name);

    //process patient's DOB and Clinical Summary: unlock if they are empty
    if( btnObj.name == 'patient' ) {

        var parentEl = getButtonElementParent(btnObj.btn);
        //console.log(parentEl);

        var dobEl = parentEl.find('.patient-dob-date');
        //console.log('dobval='+dobEl.val());
        if( dobEl.val() == '' ) {
            dobEl.attr("readonly", false);
            dobEl.removeAttr( "readonly" );
            processDatepicker(dobEl);
        } else {
            //if field has a value, then replace calendar icon with lock icon
            var inputGroup = parentEl.find('.input-group');
            //create lock icon
            if( inputGroup.find('.lock-icon-button').length == 0 ) {
                var lockGroup = '<span class="input-group-addon lock-icon-button" onclick="unlockField(this)"><i class="glyphicon glyphicon-lock"></i></span>';
                //add lockGroup to inputGroup
                inputGroup.append(lockGroup);
                //remove calendarGroup
                inputGroup.find('.calendar-icon-button').hide();
            }
        }

    }

}

function unlockField( lockBtn ) {

    var lockBtnEl = $(lockBtn);
    //printF(lockBtnEl,"unlock btn:");

    var unlock = confirm("Are you sure you would like to correct the date of birth?");

    if( unlock == true ){
        var field = lockBtnEl.parent().find('input');
        field.attr("readonly", false);
        field.removeAttr( "readonly" );
        processDatepicker(field);

		//get inputGroup
		var inputGroup = lockBtnEl.parent();
        inputGroup.find('.calendar-icon-button').show();
        inputGroup.find('.lock-icon-button').remove();
		
    } else {
        return false;
    }

}

//create information well. Do not show it for external submitter
//flag 0: Adding new *. (patient, acc number)
//flag 1: Existing patient information loaded
function setObjectInfo(btnObj,flag) {

    //check if the user is external submitter
    //getUserRole();

//    if( _external_user === false ) {
//        //console.log("show info");

        if( flag === 1 ) {
            var msg = "Existing "+btnObj.name+" information loaded";
            if( orderformtype == "single" && (btnObj.name == 'part' || btnObj.name == 'block') ) {
                var msg = "Existing "+btnObj.name;
            }
        } else {
            var msg = "Adding new "+btnObj.name;
        }

        attachInfoToElement( btnObj.element, msg );

//    } else {
//        //console.log("external user: do not show info");
//    }

}

//set blue strip info when check button is pressed
function setBlueStrip(btnObj,data) {
    //console.debug( "btnObj.name=" + btnObj.name );
    var fullObjectName = data['fullObjectName'];
    //console.log("fullObjectName=" + fullObjectName);
    if( fullObjectName ) {
        var parentEl = btnObj.btn.closest('.panel'); //panel-multi-form
        //console.log(parentEl);
        parentEl.find('.element-title-object-name').first().html(fullObjectName);
    }
}

//remove object info from blue strip
function removeBlueStrip(btnObj) {
    var parentEl = btnObj.btn.closest('.panel');
    parentEl.find('.element-title-object-name').first().html("");
}

function getValueAccordingToStatus(dataArr,status) {
    for (var i = 0; i < dataArr.length; i++) {
        if( dataArr[i]['validity'] == status ) {
            return dataArr[i];
        }
    }
    return null;
}



function attachInfoToElement( element, msg ) {
    //label label-info alert alert-success
    var html = '<div class="label label-info scanorder-element-info">'+
                msg +
            '</div>';
    element.after( html );
}

function removeInfoFromElement( btnObj ) {
    var inputEl = btnObj.element;
    //console.log(inputEl);
    var info = inputEl.parent().find('.scanorder-element-info');
    info.remove();
}

//parent - holder containing all elements for this object
function setPatientNameSexAgeLockedFields( data, parent ) {

    if( data['fullname'] && data['fullname'] != undefined && data['fullname'] != "" ) {
        setSimpleField(parent.find('.patientname').find('.not-mapped-simplefield'),data['fullname']);
    }

    if( data['sex'] && data['sex'] != undefined && data['sex'] != "" ) {
        setSimpleField(parent.find('.patientsex').find('.not-mapped-simplefield'),data['sex'][0]['text']);
    }

    if( data['age'] && data['age'] != undefined && data['age'] != "" ) {
        setSimpleField(parent.find('.patientage').find('.not-mapped-simplefield'),data['age']);
    }

}
function cleanPatientNameSexAgeLockedFields( parent ) {
    setSimpleField(parent.find('.patientname').find('.not-mapped-simplefield'),"");
    setSimpleField(parent.find('.patientsex').find('.not-mapped-simplefield'),"");
    setSimpleField(parent.find('.patientage').find('.not-mapped-simplefield'),"");
}
function setSimpleField( element, text) {
    element.html(text);
}


//documents
function setPaperDocuments( btnEl, parent, data ) {

    //console.log(parent);
    //console.log(data);

    if( !parent.hasClass('scan-partpaper') && orderformtype != "single" ) {
        return;
    }

    if( orderformtype == "single" ) {
        var btnObj = new btnObject(btnEl);
        //compare button name with holdername: 'patient' ?= 'accession'
        //console.log("compare:"+btnObj.name+"?="+'part');
        if( btnObj.name != 'part' ) {
            return;
        }
    }

    if( 1 ) {

        var documentContainerData = null;
        if( data ) {
            documentContainerData = data['paper'];
        }

        setDocumentsInDocumentConatiner(
            parent,
            documentContainerData,
            'paper',       //name
            '.partpaper'   //documentHolderClass
        );

    } else {

//    //clean fields
//    if( data == null  ) {
//
//        if( parent.find('.file-upload-dropzone').length == 1 ) {
//            parent.find('.file-upload-dropzone').removeClass('dropzone-keep-enabled');
//            parent.find('.file-upload-dropzone').find('.dz-preview').remove();
//            parent.find('.file-upload-dropzone').find('.dz-message').css('opacity','1');
//            attachTooltip(parent.find('.file-upload-dropzone'),true,'part');
//            return;
//        }
//
//        parent.find('.file-upload-dropzone').not('.dropzone-keep-enabled').closest('.row').remove();
//        parent.find('.file-upload-dropzone').removeClass('dropzone-keep-enabled');
//        parent.find('.file-upload-dropzone').find('.dz-message').css('opacity','1');
//        parent.find('.file-upload-dropzone').find('.dz-preview').remove();
//        return;
//    }
//
//    //keep enabled first paper dropzone
//    var existingDropzone = parent.find('.file-upload-dropzone').first();
//    existingDropzone.addClass('dropzone-keep-enabled');
//
//    if( data['paper'] && data['paper'] != undefined ) {
//
//        var papers = data['paper'];
//
//        if( papers.length == 0 ) {
//            return;
//        }
//
//        //console.log('papers count=' + papers.length );
//
//        for( var i=0; i<papers.length; i++ ) {
//
//            var paper = papers[i];
//
//            //console.log('paper id='+paper.id);
//
//            if( paper['documents'].length == 0 ) {
//                continue;
//            }
//
//            //create paper prototype using data-prototype-partpaper
//            var newDropzoneHolder = createDropzoneHolder_Paper(existingDropzone);
//            //console.log('newDropzoneHolder='+newDropzoneHolder);
//            var newDropzoneHolderEl = $(newDropzoneHolder);
//
//            //attach paper prototype to part after Source Organ
//            var partPaperHolder = parent.find('.partpaper');
//            partPaperHolder.prepend( newDropzoneHolderEl );
//
//            //init dropzone
//            var paperdata = processDocumentsInDocumentContainer(paper);
//            initFileUpload( newDropzoneHolderEl, paperdata, null );
//
//        }
//
//    }

    } //else

}

//function processPaperDocuments( paper ) {
//
//    var documents = paper['documents'];
//
//    //console.log('documents count=' + documents.length );
//
//    if( documents.length == 0 ) {
//        return;
//    }
//
//    var data = new Array();
//
//    for( var i=0; i<documents.length; i++ ) {
//
//        var document = documents[i];
//
//        var originalname = document['originalname'];
//        var uniquename = document['uniquename'];
//        var size = document['size'];
//        var url = document['url'];
//        var id = document['id'];
//
//        //console.log('originalname='+originalname);
//
//        var fileArr = new Array();
//        fileArr['originalname'] = originalname;
//        fileArr['uniquename'] = uniquename;
//        fileArr['size'] = size;
//        fileArr['url'] = url;
//        fileArr['id'] = id;
//        data.push(fileArr);
//
//    }
//
//    return data;
//}

//function createDropzoneHolder(existingDropzoneHolder) {
//
//    var dataElement = document.getElementById("form-prototype-data");
//    var prototype = dataElement.getAttribute('data-prototype-partpaper');
//
//    //console.log('prototype='+prototype);
//
//    //printF(existingDropzoneHolder,"existingDropzoneHolder:");
//    //console.log(existingDropzoneHolder);
//
//    var paperidElement = existingDropzoneHolder.parent().find('.field-partpaperothers');
//    //var paperidElement = existingDropzoneHolder.closest('.partpaper').find('.field-partpaperothers'); //this will get incorrect paperid
//
//    //console.log('count paperidElement='+paperidElement.length);
//
//    if( !paperidElement || paperidElement.length == 0 ) {
//        throw new Error("Paper element is not found");
//    }
//
//    //printF(paperidElement,"paperidElement:");
//    //console.log(paperidElement);
//
//    var id = paperidElement.last().attr('id');
//
//    if( !id || id == "" ) {
//        throw new Error("Paper id element is not found");
//    }
//
//    var idArr = id.split("_");
//
//    //  0       1               2           3    4     5     6     7     8      9   10  11  12  13  14  15
//    //oleg_orderformbundle_messagetype_patient_0_encounter_0_procedure_0_accession_0_part_0_paper_0_others
//    var patientid = idArr[4];
//    var encounterid = idArr[6];
//    var procedureid = idArr[8];
//    var accessionid = idArr[10];
//    var partid = idArr[12];
//    var paperid = idArr[14];
//
//    var newForm = prototype.replace(/__patient__/g, patientid);
//    newForm = newForm.replace(/__encounter__/g, encounterid);
//    newForm = newForm.replace(/__procedure__/g, procedureid);
//    newForm = newForm.replace(/__accession__/g, accessionid);
//    newForm = newForm.replace(/__part__/g, partid);
//    newForm = newForm.replace(/__partpaper__/g, paperid);
//
//
//    return newForm;
//}





















//TODO: functions to rewrite


//all: "all" => disable/enable all fields including key field
//flagKey: "notkey" => disable/enable all fields, but not key field (inverse key)
//flagArrayField: "notarrayfield" => disable/enable array fields
function disableInElementBlock( element, disabled, all, flagKey, flagArrayField ) {

    //console.log("disable element.id=" + element.attr('id') + ", class=" + element.attr("class") );

    //attach tooltip for not real permanent locked fields: name, age, sex
    attachPatientNameSexAgeLockedTooltip();

    var parentname = ""; //for multi form
    if( element.hasClass('accessionbtn') ) {
        parentname = "accession";
    }
    if( element.hasClass('partbtn') ) {
        parentname = "part";
    }
    if( element.hasClass('blockbtn') ) {
        parentname = "block";
    }
    if( element.hasClass('patientmrnbtn') ) {
        parentname = "patient";
    }

    var parent = getButtonElementParent( element );

    //console.log("parent.id=" + parent.attr('id') + ", parent.class=" + parent.attr('class'));

    var elements = parent.find(selectStr).not("*[id^='s2id_']");

    //console.log("elements.length=" + elements.length);

    for (var i = 0; i < elements.length; i++) {

        //console.log("\n\nDisable element.id=" + elements.eq(i).attr("id")+", class="+elements.eq(i).attr("class"));
        //  0         1              2           3   4  5
        //oleg_orderformbundle_messagetype_patient_0_mrn  //length=6
        var id = elements.eq(i).attr("id");
        var type = elements.eq(i).attr("type");

        //dropzone
        if( elements.eq(i).hasClass('file-upload-dropzone') ) {

            disableEnableDropzone( elements.eq(i), disabled, 'part' );

//            var dropzoneDom = elements.eq(i).get(0);
//            //console.log('disable/enable dropzone className='+dropzoneDom.className);
//            var myDropzone = dropzoneDom.dropzone;
//
//            if( disabled && !elements.eq(i).hasClass('dropzone-keep-enabled') ) {
//                //disable
//                elements.eq(i).removeClass('dz-clickable'); // remove cursor
//                dropzoneDom.removeEventListener('click', myDropzone.listeners[1].events.click);
//                //add tooltip
//                attachTooltip(elements.eq(i),true,'part');
//            } else {
//                //enable
//                elements.eq(i).addClass('dz-clickable'); // add cursor
//                dropzoneDom.addEventListener('click', myDropzone.listeners[1].events.click);
//                //remove tooltip
//                attachTooltip(elements.eq(i),false,'part');
//            }

            //console.log('dropzone maxfiles(10?)='+myDropzone.options.maxFiles);
            continue;
        }

        //don't process elements not belonging to this button
        if( fieldBelongsToButton( element, elements.eq(i) ) === false ) {
            //console.log("this field does not belong to clicked button");
            continue;
        }

        //don't process slide fields
        if( id && id.indexOf("_slide_") != -1 ) {
            continue;
        }

        //don't process fields not containing patient (message fields)
        if( id && id.indexOf("_patient_") == -1 ) {
            continue;
        }

//      //console.log("proceed before submitted by single form ...");
        //don't process patient fields if the form was submitted by single form: click on accession,part,block delete button
//        if( orderformtype == "single" && id && id.indexOf("_procedure_") == -1 ) {
//            continue;
//        }

        //don't process 0 disident field: part's Diagnosis :
        if( orderformtype == "single" && id && id.indexOf("disident_0_field") != -1 ) {
            continue;
        }

        if( id && type != "hidden" ) {

            var thisfieldIndex = fieldIndex;
            if( type == "radio" ) {
                var thisfieldIndex = fieldIndex + 1;
            }

            var idsArr = elements.eq(i).attr("id").split("_");
            var field = idsArr[idsArr.length-thisfieldIndex];
            //console.log("disable field=(" + field + ")");

            if( all == "all" ) {
                disableElement(parentname, elements.eq(i),disabled);
            }

            if( flagKey == "notkey" ) {
                //check if the field is not key
                //printF(elements.eq(i),"check " + field+" if key: ");
                if( isKey(elements.eq(i), field) && flagKey == "notkey" ) {
                    //console.log("key!");
                    if( disabled ) {    //inverse disable flagKey for key field
                        //console.log("disable field=(" + field + ")");
                        disableElement(parentname,elements.eq(i),false);
                    } else {
                        //console.log("enable field=(" + field + ")");
                        disableElement(parentname,elements.eq(i),true);
                    }
                } else {
                    //console.log("not key!");
                    disableElement(parentname,elements.eq(i),disabled);
                }
            }

            if( flagArrayField == "notarrayfield" ) {
                if( $.inArray(field, arrayFieldShow) != -1 ) {
                    //console.log("Arrayfield: disable/enable array id="+elements.eq(i).attr("id"));
                    if( elements.eq(i).attr("id") && elements.eq(i).attr("id").indexOf(field+"_0") != -1 ) {
                        //console.log(field+"_0_field'");
                        if( disabled ) {    //inverse disable flag for key field
                            disableElement(parentname,elements.eq(i),false);
                        } else {
                            disableElement(parentname,elements.eq(i),true);
                        }
                    }
                }               
            }

        }

    }
}

//disable or enable element
function disableElement( parentname, element, flag) {

    var type = element.attr('type');
    var classs = element.attr('class');
    var tagName = element.prop('tagName');

    //console.log("disable classs="+classs+", tagName="+tagName+", type="+type+", id="+element.attr('id')+", flag="+flag);

    //return if this element does not belong to a pressed key element
    var idArr = element.attr('id').split("_");
    var fieldParentName = idArr[idArr.length-holderIndex];
    if( fieldParentName == "encounter"  || fieldParentName == "procedure" ) {
        fieldParentName = "accession";
    }

    //console.log("fieldParentName="+fieldParentName+", parentname="+parentname);
    if( parentname == "" || parentname == fieldParentName ) {
        //console.log("continue");
    } else {
        return;
    }

    attachTooltip(element,flag,fieldParentName);

    if( tagName == "DIV" && classs.indexOf("select2") == -1 ) { //only for checkbox group
        //console.debug("checkbox disable classs="+classs+", id="+element.attr('id'));
        processGroup( element, "", flag );
        return;
    }

    if( tagName == "SELECT" || typeof classs !== "undefined" && classs.indexOf("select2") != -1 && ( tagName == "DIV" || tagName == "INPUT" ) ) { //only for select group
        //console.log("select disable classs="+classs+", id="+element.attr('id')+", flag="+flag);
        if( flag ) {    //disable
            //console.log("disable select2");
            element.select2("readonly", true);
        } else {    //enable
            //console.log("enable select2");
            element.select2("readonly", false);
            element.attr("readonly", false);
            element.removeAttr( "readonly" );
            //element.removeAttr( "disabled" );

        }
        return;
    }

    //process complex fields
    processInputGroupCheckboxFields(element,null,flag,'disable');

    if( flag ) {

        if( type == "file" ) {
            //console.log("file disable field id="+element.attr("id"));
            element.attr('disabled', true);
        } else {
            //console.log("general disable field id="+element.attr("id"));
            element.attr('readonly', true);
        }

        if( classs && classs.indexOf("datepicker") != -1 ) {
            //console.log("disable datepicker classs="+classs);
            processDatepicker(element,"remove");
        }

        //disable children buttons
        element.parent().find("span[type=button],button[type=button]").attr("disabled", "disabled");

    } else {

        if( type == "file" ) {
            //console.log("file enable field id="+element.attr("id"));
            element.attr('disabled', false);
        } else {
            //console.log("general enable field id="+element.attr("id"));
            element.attr("readonly", false);
            element.removeAttr( "readonly" );
        }

        //enable children buttons
        element.parent().find("span[type=button],button[type=button]").removeAttr("disabled");

        if( classs && classs.indexOf("datepicker") != -1 ) {
            //console.log("enable datepicker classs="+classs);
            processDatepicker(element);
        }

    }
}

//set Element. Element is a block of fields
//element: check_btn element
//cleanall: clean all fields
//key: set only key field
function setElementBlock( element, data, cleanall, key ) {

    //console.debug( "element.id=" + element.attr('id') + ", class=" + element.attr('class') );

    var parent = getButtonElementParent( element );

    setPatientNameSexAgeLockedFields(data,parent);

    setPaperDocuments(element,parent,data);

    //console.log(parent);
    //console.log("key="+key+", single="+single);
    //printF(parent,"Set Element Parent: ");

    if( key == "key" && orderformtype == "single" && !element.hasClass("patientmrnbtn") ) {
        var inputField = element.parent().find('.keyfield').not("*[id^='s2id_']");
        //console.log("inputField.id=" + inputField.attr('id') + ", class=" + inputField.attr('class'));
        //console.log(inputField);
        var idsArrTemp = inputField.attr("id").split("_");
        var field = idsArrTemp[idsArrTemp.length-fieldIndex];    //default
        //console.log("Single Key field=" + field);
        if( field == "partname" ) {
            var elements = $('#part-single').find('.keyfield').not("*[id^='s2id_']");
        } else if( field == "blockname" ) {
            var elements = $('#block-single').find('.keyfield').not("*[id^='s2id_']");
        } else if( field == "accession" ) {
            //var elements = $('#accession-single').find('.keyfield').not("*[id^='s2id_']");
            var elements = $('.singlemessage').find('.accessiontype-combobox').not("*[id^='s2id_']");    //treat accession as a group
        } else if( field == "mrn" ) {
            var elements = $('.singlemessage').find('.mrntype-combobox').not("*[id^='s2id_']");    //treat mrn as a group
        } else {
            //console.debug('WARNING: logical error! No key for single order form is found: field='+field);
        }
    } else {
        //console.log("regular set element block");
        var elements = parent.find(selectStr).not("*[id^='s2id_']");
    }

    //console.log("elements.length=" + elements.length);

    for( var i = 0; i < elements.length; i++ ) {

        //console.log('\n\n'+"Set Element.id=" + elements.eq(i).attr("id")+", class="+elements.eq(i).attr("class"));

        //  0         1              2           3   4  5
        //oleg_orderformbundle_messagetype_patient_0_mrn  //length=6
        var id = elements.eq(i).attr("id");
        var type = elements.eq(i).attr("type");
        var classs = elements.eq(i).attr("class");
        var value = elements.eq(i).attr("value");
        //console.log("id=" + id + ", type=" + type + ", class=" + classs + ", value=" + value );

        //don't process elements not belonging to this button
        if( fieldBelongsToButton( element, elements.eq(i) ) === false ) {
            continue;
        }

        //exception
        if( id && id.indexOf("primaryOrgan") != -1 ) {
            //console.log("skip id="+id);
            continue;
        }

        //don't process ajax-combobox-staintype. It will be populated by block's field field
        if( elements.eq(i).hasClass('ajax-combobox-staintype') ) {
            continue;
        }

        if( id ) {

            var idsArr = elements.eq(i).attr("id").split("_");
            var field = idsArr[idsArr.length-fieldIndex];    //default
            //console.log("######## field = " + field);// + ", data text=" + data[field]['text']);

            if( key == "key" ) {

                if( $.inArray(field, keys) != -1 ) {
                    //console.log("set key field = " + data[field][0]['text'] );
                    setArrayField( elements.eq(i), data[field], parent );
                    //elements.eq(i).val(data[field]);
                    break;
                }
            }

//            if( type == "radio" ) {
//                field = idsArr[idsArr.length-(fieldIndex + 1)];
//            }

            if( type == "hidden" ) {
                field = idsArr[idsArr.length-(fieldIndex + 1)];
            }

            if( data == null  ) {   //clean fields
                //console.log("data is null");
                if( $.inArray(field, keys) == -1 || cleanall) {
                    elements.eq(i).val(null);   //clean non key fields
                } else {
                    //console.log("In array. Additional check for field=("+field+")");
                    if( field == "partname" ) {
                        var holder = idsArr[idsArr.length-holderIndex];
                        //console.log("holder="+holder);
                        if( holder != "part" && holder != "block" ) {
                            //console.log("disable!!!!");
                            elements.eq(i).val(null);   //clean non key fields with filed "name"
                        }
                    }
                }
            } else {

                //get field name for select fields i.e. procedure
                if( classs && classs.indexOf("select2") != -1 ) {

                    holder = idsArr[idsArr.length-holderIndex];
                    //console.log("select2 holder="+holder);
                    if( holder != "part" && holder != "block" && holder != "patient" ) {
                        field = holder;
                        //console.log("new field="+field);
                    }
                }

                //console.log("2 field = " + field);
                if( data[field] && data[field] != undefined && data[field] != "" ) {
                    //console.log("data is not null: set text for field " + field);
                    setArrayField( elements.eq(i), data[field], parent );
                } else {
                    //console.log("data is empty: don't set text field");
                }

                //console.log("diseaseTypeRender");
                //diseaseTypeRender();

            }

        }

    } //for

}

//set array field such as ClinicalHistory array fields
//element is an input element jquery object
function setArrayField(element, dataArr, parent) {

    //console.log(dataArr);

    if( !dataArr ) {
        return false;
    }

    var type = element.attr("type");
    var classs = element.attr("class");
    var tagName = element.prop("tagName");
    var value = element.attr("value");
    //console.log("Set array: type=" + type + ", id=" + element.attr("id")+", classs="+classs + ", len="+dataArr.length + ", value="+value+", tagName="+tagName);

    for (var i = 0; i < dataArr.length; i++) {

        //var dataArr = data[field];
        var id = dataArr[i]["id"];
        var text = dataArr[i]["text"];
        var provider = dataArr[i]["provider"];
        var date = dataArr[i]["date"];
        var validity = dataArr[i]["validity"];
        var coll = i+1;

        //console.log( "set array field i="+i+", id="+id+", text=" + text + ", provider="+provider+", date="+date + ", validity="+validity );

        if( (validity == 'invalid' || validity == 'deidentified-valid' || validity == 'deidentifier') && dataArr.length > 1 ) {
            continue;
        }

        //console.log("parent id=" + parent.attr("id"));
        var idsArr = parent.attr("id").split("_");
        var elementIdArr = element.attr("id").split("_");
        //console.log("in loop parent.id=" + parent.attr("id") + ", tagName=" + tagName + ", type=" + type + ", classs=" + classs + ", text=" + text );

        var fieldName = elementIdArr[elementIdArr.length-fieldIndex];
        var holderame = elementIdArr[elementIdArr.length-holderIndex];
        var ident = holderame+fieldName;
        //console.log("ident=" + ident + ", coll="+coll );

        //var attachElement = element.parent().parent().parent().parent().parent();

        var attachElement = parent.find("."+ident.toLowerCase());   //patientsex

        //console.log("attachElement class="+attachElement.attr("class")+",id="+attachElement.attr("id"));

        //create an empty input for array fields if populated. Preset id with entity id. Later, set text value as for a normal field
        if( $.inArray(fieldName, arrayFieldShow) != -1 ) { //show all fields from DB

            //var name = idsArr[0];
            var patient = idsArr[1];
            var encounter = idsArr[2];
            var procedure = idsArr[3];
            var accession = idsArr[4];
            var part = idsArr[5];
            var block = idsArr[6];
            var slide = idsArr[7];

            //console.log("Create array empty field, fieldName=" + fieldName + ", patient="+patient+", part="+part + ", id="+id + ", text="+text );

            var newForm = getCollField( ident, patient, encounter, procedure, accession, part, block, slide, coll );
            //console.log("newForm="+newForm);

//            if( fieldName == "specialStains" ) {
//                //special stain has id of the staintype select box
//                id = dataArr[i]["staintype"];
//            }

            var labelStr = " entered on " + date + " by "+provider + "</label>";
            newForm = newForm.replace("</label>", labelStr);

            var idStr = 'type="hidden" value="'+id+'" ';
            //console.log("idStr="+idStr);
            newForm = newForm.replace('type="hidden"', idStr);

            //console.log("newForm="+newForm);

            if( fieldName == "disident" && orderformtype == "single" ) {
                //attachElement = $('.partdiffdisident');
                attachElement = $('#partdisident_marker'); //TODO: test it!!!
                //console.log("attachElement class="+attachElement.attr("class")+",id="+attachElement.attr("id"));
                $('#partdisident_marker').append(newForm);
            } else {
                //console.log("attachElement class="+attachElement.attr("class")+",id="+attachElement.attr("id"));
                attachElement.prepend(newForm);
            }

            //console.log("attachElement class="+attachElement.attr("class")+",id="+attachElement.attr("id"));

            if( fieldName == "specialStains" ) {
                //console.log('staintype='+dataArr[i]["staintype"]);
                //pre-populate select2 with stains
                getComboboxSpecialStain(new Array(patient,encounter,procedure,accession,part,block,coll),true,dataArr[i]["staintype"]);
            }

        } else {    //show the valid field (with validity=1)
            //console.log("NO array Fiel dShow");
        }

        //set data
        if( tagName == "INPUT" ) {
            //console.log("input tagName: fieldName="+fieldName);

            //process input-group such as encounter-firstName
            processInputGroupCheckboxFields(element,dataArr[i],null,'set');

            if( type == "file" ) {

                element.hide();
                //var paperLink = '<a href="../../../../web/uploads/documents/'+dataArr[i]["path"]+'" target="_blank">'+dataArr[i]["name"]+'</a>';
                var paperLink = text;
                //console.log("paperLink="+paperLink);
                element.parent().append(paperLink);

            }
            else if( classs && classs.indexOf("datepicker") != -1 ) {
                //console.log("set array: datepicker");
                var firstAttachedElement = attachElement.find('input').first();
                if( text && text != "" ) {
                    //console.log("set date, text"+text);
                    firstAttachedElement.datepicker( 'setDate', new Date(text) );
                    firstAttachedElement.datepicker( 'update');
                } else {
                    //console.log("set array: init datepicker");
                    initSingleDatepicker(firstAttachedElement);
                }
            }
            else if( type == "text" ) {
                //console.log("type text, text="+text);

                if( fieldName == "accession" || fieldName == "mrn" ) {
                    setKeyGroup(element,dataArr[i]);
                    continue;
                }

                //save keys for single form, because all keys will be removed by the first clean functions
                if( orderformtype == "single") {
                    if( fieldName == "partname" ) {
                        partKeyGlobal = text;
                    }
                    if( fieldName == "blockname" ) {
                        blockKeyGlobal = text;
                    }
                }

                //find the last attached element to attachElement
                //var firstAttachedElement = attachElement.find('input,textarea').first();
                var firstAttachedElement = attachElement.find('input[type=text]').first();

                //override firstAttachedElement, because first element is hidden id, but we need to find input field
                if( fieldName == "diffDisident" && orderformtype == "single" ) {
                    firstAttachedElement = $('.partdiffdisident').find('.partdiffdisident-field').first();
                }

                //printF(firstAttachedElement,fieldName+": firstAttachedElement: ");

                if( fieldName == "partname" || fieldName == "blockname" ) {
                    if( orderformtype == "single" ) {
                        var firstAttachedElement = element;
                    } else {
                        var firstAttachedElement = attachElement.find('.keyfield ').first();
                    }
                    //printF(firstAttachedElement,"firstAttachedElement=");
                    firstAttachedElement.select2('data', {id: text, text: text});
                } else {
                    if( classs.indexOf("select2") != -1 ) {
                        var firstAttachedElement = element;
                        //printF(firstAttachedElement,"firstAttachedElement=");
                        //console.log("!!!!!!!!!!!! Set Value as select="+text+", id="+id);
                        firstAttachedElement.select2('data', {id: text, text: text});
                        //firstAttachedElement.select2('val', id);
                    } else {
                        //console.log("!!!!!!!!!!!! Set Value text="+text);
                        firstAttachedElement.val(text);
                    }
                }

            }


        } else if ( tagName == "TEXTAREA" ) {

            if( fieldName == "disident" && orderformtype == "single" ) {
                var firstAttachedElement = $('#partdisident_marker').find('.row').find('textarea'); //the last diffDiagnosis field is part's disident field
                //console.log("disident: " + firstAttachedElement.attr("class")+",id="+firstAttachedElement.attr("id") + ", text="+text);
            } else {
                var firstAttachedElement = attachElement.find('textarea').first();
            }

            //console.log("textarea firstAttachedElement class="+firstAttachedElement.attr("class")+",id="+firstAttachedElement.attr("id") + ", text="+text);
            firstAttachedElement.val(text);

        } else if ( (tagName == "DIV" && classs.indexOf("select2") != -1) || tagName == "SELECT" ) {

            //console.log("### DIV select2:  select field, id="+id+",text="+text);
            //console.log("id="+element.attr("id"));

            //set mrntype
            if( fieldName == "mrn" || fieldName == "accession" ) {
                //mrnKeyGlobal = text;
                //mrnKeytypeGlobal = dataArr[i]["keytype"];
                setKeyGroup(element,dataArr[i]);
            } else {
                element.select2('data', {id: text, text: text}); //TODO: set by id .select2.('val':id);
            }

        } else if ( tagName == "DIV" ) {
            //console.log("### set array field as DIV, id="+element.attr("id")+", text="+text );
            //get the first (the most recent added) group
            var firstAttachedElement = attachElement.find('.horizontal_type').first();
            processGroup( firstAttachedElement, dataArr[i], "ignoreDisable" );
        } else {
            //console.log("logical error: undefined tagName="+tagName);
        }

        //set hidden id of the element
        var directParent = element.parent().parent().parent();
        //console.log("hidden directParent="+directParent.attr("id") + ", class="+directParent.attr("class") );
        if( $.inArray(fieldName, arrayFieldShow) == -1 ) {
            var hiddenElement = directParent.find('input[type=hidden]');
            hiddenElement.val(id);
            //console.log("set hidden "+fieldName+", set id="+id + " hiddenId="+hiddenElement.attr("id") + " hiddenClass="+hiddenElement.attr("class") );
        }

    } //for loop

}

//set key type field. Used by set and clean functions
//element - is key type element (combobox): id=oleg_orderformbundle_messagetype_patient_0_encounter_0_procedure_0_accession_0_accession_0_keytype
function setKeyGroup( element, data ) {
    //console.log("########### set key group: element id="+element.attr("id") + ", class="+element.attr("class")+", keytype="+data['keytype']+", text="+data['text']);

    if( element.attr('class').indexOf("combobox") == -1 ) {
        //console.log("key group: not a a keytype combobox => return");
        return;
    }

    var holder = element.closest('.row');
    //printF(holder,"Holder of key group:");

    //var keytypeEl = holder.find('select.combobox');
    var keytypeEl = holder.find('.combobox').first();
    //var keytypeEl = element;
    //var keytypeEl = new typeByKeyInput(element).typeelement;
    //var typeObj = new typeByKeyInput(element);
    //this.type = typeObj.type;
    //this.typename = typeObj.typename;
    //var keytypeEl = typeObj.typeelement;

    //printF(keytypeEl,"Set Key Group: keytype Element:");

    //do not change type only if current type is "existing.." and returned keytypename is "auto-generated"
    var currentKeytypeText = keytypeEl.select2("data").text;
    var currentKeytypeId = keytypeEl.select2("data").id;
    var currentKeytypeVal = keytypeEl.select2("val");

    var tosetKeytypeText = data['keytypename'];

    //console.log('Keytype: tosetKeytypeText='+tosetKeytypeText +', currentKeytypeText='+currentKeytypeText+", currentKeytypeId="+currentKeytypeId+", currentKeytypeVal="+currentKeytypeVal);

    if( tosetKeytypeText && tosetKeytypeText.indexOf("Auto-generated") != -1 && currentKeytypeText.indexOf("Existing Auto-generated") != -1 ) {
        //don't change type
        //console.log('dont change keytype: tosetKeytypeText='+tosetKeytypeText);
    } else {
        //console.log('change keytype: tosetKeytypeText='+tosetKeytypeText);
        keytypeEl.select2('val', data['keytype']);
    }

    //element.select2( 'data', { text: data['keytypename'] } );

    //TODO: what to do when amend with check boxes
    if( element.hasClass('mrntype-combobox') ) {
        setMrntypeMask(element,false); //true
    }
    if( element.hasClass('accessiontype-combobox') ) {
        setAccessiontypeMask(element,false); //true
    }
    //console.log("Set Key Group: asseccionKeyGlobal="+asseccionKeyGlobal+", asseccionKeytypeGlobal="+asseccionKeytypeGlobal+", partKeyGlobal="+partKeyGlobal+", blockKeyGlobal="+blockKeyGlobal+", mrnKeyGlobal="+mrnKeyGlobal+", mrnKeytypeGlobal="+mrnKeytypeGlobal);

    var inputholder = getButtonParent(element);
    var keyEl = inputholder.find('input.keyfield');
    //console.log("set keytype group: keyEl id="+keyEl.attr("id") + ", class="+keyEl.attr("class")+", keyEl.length="+keyEl.length);
    keyEl.val(data['text']);
}

//process groups such as radio and checkbox button group
function processGroup( element, data, disableFlag ) {

    //printF(element,"disableFlag="+disableFlag+": process group:");

    if( typeof element.attr("id") == 'undefined' || element.attr("id") == "" ) {
        return;
    }

    var elementIdArr = element.attr("id").split("_");
    var fieldName = elementIdArr[elementIdArr.length-(fieldIndex+1)];

    //var element = elementInside.parent().parent().parent();
    //var radios = element.find("input:radio");

    //console.log("process group id="+element.attr("id")+ ", class="+element.attr("class") + ", fieldName="+fieldName );

    //var partId = 'input[id*="'+fieldName+'_"]:radio';
    var partId = 'input[id*="'+fieldName+'_"][type=radio],input[id*="'+fieldName+'_"][type=checkbox]';
    //console.log("partId=" + partId );

    var members = element.find(partId);
    //console.log('members.length='+members.length);

    for( var i = 0; i < members.length; i++ ) {
        var localElement = members.eq(i);
        var value = localElement.attr("value");
        //console.log("radio id: " + localElement.attr("id") + ", value=" + value );

        if( disableFlag == "ignoreDisable" ) {  //use to set radio box

            if( data && data != "" ) {  //set fields with data
                //console.log("data ok, check radio (data): " + value + "?=" + data['text'] + ",id="+data['id'] );

                //check if current checkbox value (diseasetype id) is in array of data['diseasetypes']
                var index = -1;
                for( var ii = 0; ii < data['diseasetypes'].length; ii++ ) {
                    //console.log("data check :" + value + "==" + data['diseasetypes'][ii]['id'] );
                    if( data['diseasetypes'][ii]['id'] == value ) {
                        index = ii;
                        break;
                    }
                }
                //console.log("index=" + index );

                //if( value == data['text'] ) {
                if( index > -1 ) {
                    //console.log("Match!" );
                    //console.log("show and set children: disableFlag="+disableFlag+", diseasetypes="+data['diseasetypes']+", diseaseorigins="+data['diseaseorigins']+", primaryorgan="+data['primaryorgan']);
                    localElement.prop('checked',true);
                    diseaseTypeRenderCheckForm(element,data['diseasetypes'],data['diseaseorigins'],data['primaryorgan']);    //set diseaseType group
                }
                localElement.attr("disabled", true);
            } else {
                //console.log("no data radio: value=" + value);
                //console.log("hide children: disableFlag="+disableFlag);
                localElement.prop('checked',false);
                hideDiseaseTypeChildren( element ); //unset and hide diseaseType group

            }

        } else  {
            if( disableFlag ) {
                //console.log("disable radio: value=" + value);
                localElement.attr("disabled", true);
            } else {
                //console.log("enable radio: value=" + value);
                localElement.prop("disabled", false);
            }
        }

    }

}

//process fields that part of input-group class
function processInputGroupCheckboxFields(element,data,disableFlag,action) {

    var parent = element.parent();
    //console.log("processInputGroupCheckboxFields");

    if( parent.hasClass('input-group') ) {

        var value = null;
        var alias = null;

        if( data ) {
            value = data['text'];
            if( 'alias' in data ) {
                alias = data['alias'];
            }
        }

        parent.find('input:checkbox').each( function() {

            //printF($(this),"process input group checkbox:");

            //assign value
            if( action == 'set' && alias == 1 ) {
                //console.log("checkbox set true !!!");
                $(this).prop('checked', true);
            }

            //enable/disable
            if( action == 'disable' ) {
                $(this).prop('disabled', disableFlag);
            }

            if( action == 'clear' ) {
                //console.log("checkbox set false");
                $(this).prop('checked', false);
            }

        });

    }

}

//check for single form if the field belongs to the button
function fieldBelongsToButton(btn,fieldEl) {

    if( orderformtype != "single") {
        return true;
    }

    var id = fieldEl.attr('id');

    if( !id || typeof id === "undefined" || id == "" ) {
        return false;
    }

    var idsArr = id.split("_");
    //var fieldName = idsArr[idsArr.length-fieldIndex];
    var holdername = idsArr[idsArr.length-holderIndex];

    var btnObj = new btnObject(btn);

    //compare button name with holdername: 'patient' ?= 'accession'
    //console.log("compare:"+btnObj.name+"?="+holdername);
    if( btnObj.name == holdername ) {
        return true;
    }

    //excemption: encounter/procedure does not have its own button; it is triggered by accession
    if( btnObj.name == 'accession' && (holdername == 'procedure' || holdername == 'encounter') ) {
        return true;
    }

    return false;
}

function cleanArrayFieldSimple( element, field, single ) {
    //console.log( "clean simple array field id=" + element.attr("id") );

    //delete if id != 0
    if( element.attr("id") && element.attr("id").indexOf(field+"_0_field") != -1 ) {
        element.val(null);
    } else {
        element.parent().parent().remove();
    }
}

function cleanBlockSpecialStains( element, field, single ) {

    //printF(element,'clean block element:');

    //don't process special staintype. It will be processed by special stain field.
    if( element.hasClass('ajax-combobox-staintype') ) {
        return;
    }

    //don't process not 0 id. They will be delete by 0 id field
    //if( element.attr('id').indexOf("specialStains_0_field") == -1 ) {
    //    return;
    //}

    //console.log( "\nClean Block Special Stains elements id=" + element.attr("id") + ", field=" + field );

    var fieldHolder = element.closest('.blockspecialstains');
    var fieldInputColls = fieldHolder.find('.fieldInputColl');
    //console.log( "fieldInputColls.length=" + fieldInputColls.length );

    if( fieldInputColls.length == 0 ) {
        return false;
    }

    var stainfieldEl = fieldInputColls.first().find('.input-group-oleg').find('textarea');
    var idsArr = stainfieldEl.attr("id").split("_");

    fieldInputColls.each( function() {
        $(this).closest('.row').remove();
    });

    //construct new 0 special stain group
    var patient = idsArr[4];
    var encounter = idsArr[6];
    var procedure = idsArr[8];
    var accession = idsArr[10];
    var part = idsArr[12];
    var block = idsArr[14];
    var slide = null;
    var ident = "block"+"specialStains";
    var newForm = getCollField( ident, patient, encounter, procedure, accession, part, block, slide, 0 );
    fieldHolder.prepend(newForm);
    getComboboxSpecialStain(new Array(patient,encounter,procedure,accession,part,block,0),true);

//    //set to the first item
//    if( field == "specialStains" ) {
//        setElementToId( element, _stain );
//    }
}

function cleanPartDiffDisident( element, field, single ) {

    //console.log( "\nClean Part Diff Disident elements id=" + element.attr("id") + ", field=" + field );

    var fieldHolder = element.closest('.partdiffdisident');
    var fieldInputColls = fieldHolder.find('.form-control');
    //console.log( "fieldInputColls.length=" + fieldInputColls.length );

    if( fieldInputColls.length == 0 ) {
        return false;
    }

    var stainfieldEl = fieldInputColls.first();
    var idsArr = stainfieldEl.attr("id").split("_");

    fieldInputColls.each( function() {
        $(this).closest('.row').remove();
    });

    //construct new 0 special stain group
    //oleg_orderformbundle_messagetype_patient_0_encounter_0_procedure_0_accession_0_part_0_diffDisident_1_field
    var patient = idsArr[4];
    var encounter = idsArr[6];
    var procedure = idsArr[8];
    var accession = idsArr[10];
    var part = idsArr[12];
    var block = null;
    var slide = null;
    var ident = "part"+"diffDisident";
    var newForm = getCollField( ident, patient, encounter, procedure, accession, part, block, slide, 0 );
    fieldHolder.prepend(newForm);
}

function cleanPartDisident( element, field, single ) {

    //console.log( "\nClean Part Disident elements id=" + element.attr("id") + ", field=" + field );

    //just clean tex from 0 field
    if( element.attr('id').indexOf("disident_0_field") != -1 ) {
        element.val(null);
        return;
    }

    var fieldHolder = element.closest('#partdisident_marker');
    var fieldInputColls = fieldHolder.find('textarea');
    //console.log( "fieldInputColls.length=" + fieldInputColls.length );

    if( fieldInputColls.length == 0 ) {
        return;
    }

    fieldInputColls.each( function() {
        $(this).closest('.row').remove();
    });
}

//this function clean a provided single element
function cleanPatientClinicalHistory( element, field, single ) {

    //console.log( "\nClean Patient ClinicalHistory elements id=" + element.attr("id") + ", field=" + field );

    //just clean text from 0 field
    if( element.attr('id').indexOf("clinicalHistory_0_field") != -1 ) {
        element.val(null);
        return;
    }

    var rowElement = element.closest('.row');
    rowElement.remove();
}

//element - input field element
function cleanArrayField( element, field, single ) {

    //console.log( "Clean field=" + field );

    if( field == "specialStains" ) {
        cleanBlockSpecialStains(element, field, single);
        return;
    }

    if( field == "diffDisident" ) {
        cleanPartDiffDisident(element, field, single);
        return;
    }

    if( field == "disident" && orderformtype == "single" ) {
        cleanPartDisident(element, field, single);
        return;
    }

    if( field == "clinicalHistory" ) {
        cleanPatientClinicalHistory(element, field, single);
        return;
    }

    if( $.inArray(field, arrayFieldShow) == -1 ) {
        cleanArrayFieldSimple(element,field,single);
        return;
    }


    //clean array field id=oleg_orderformbundle_messagetype_patient_0_encounter_0_procedure_0_accession_0_part_0_diffDisident_2_field
    //console.log( "\nclean array element id=" + element.attr("id") + ", field=" + field );
    //delete if id != 0 or its not the last element

    //get row element - fieldHolder
    if( element.is('[readonly]') ) {    //get row for gray out fields without buttons
        //console.log( "readonly" );
        var fieldHolder = element.parent().parent();
    } else {
        //console.log( "not readonly" );
        var fieldHolder = element.parent().parent().parent().parent().parent();
    }

    //console.log( "fieldHolder id=" + fieldHolder.attr("id") + ", class=" + fieldHolder.attr("class") );

    var rows = fieldHolder.parent().find('.row');

    //console.log( "rows.length=" + rows.length );

    if( rows.length == 0 ) {
        return false;
    }

    //if( element.attr("id") && element.attr("id").indexOf(field+"_0_field") != -1 || rows.length == 1 ) {
    if( rows.length == 1 ) {

        element.val(null);

        //change - button (if exists) by + button
        var delBtn = element.parent().find('.delbtnCollField');
        //console.log("work on delBtn id="+delBtn.attr("id")+",class="+delBtn.attr("class"));
        if( delBtn.length != 0 ) {

            //console.log("delBtn exists !");
            //add + btn if not exists
            var addBtn = element.parent().find('.addbtnCollField');
            //console.log("work on addBtn id="+addBtn.attr("id")+",class="+addBtn.attr("class"));
            if( addBtn.length == 0 ) {
                delBtn.after( getAddBtn() );
            }

            delBtn.remove();
        } else {
            //console.log("no delBtn");
        }

        //Optional: change id of all element in row to '0'. This will bring the form to the initial state.
        changeIdtoIndex(element,field,0);

    } else {
        //delete hole row
        //console.log( "prepare to delete: fieldHolder id=" + fieldHolder.attr("id") + ", class=" + fieldHolder.attr("class") );
        //console.log(fieldHolder);
        //disident "Diagnosis" field has fieldHolder "Slide Info" for a single form.
        //It is array field for single form ( arrayFieldShow.push("disident") ), however it is excemption field because it's single
        //if( fieldHolder.attr("id") != "single-scan-order-slide-info" && fieldHolder.hasClass("panel") ) {
        if( !fieldHolder.hasClass("panel") ) {
            //console.log( "delete: fieldHolder id=" + fieldHolder.attr("id") + ", class=" + fieldHolder.attr("class") );
            fieldHolder.remove();
        }
    }
}

function changeIdtoIndex( element, field, index ) {

    //get row element - fieldHolder
    if( element.is('[readonly]') ) {    //get row for gray out fields without buttons
        var fieldHolder = element.parent().parent();
    } else {                            //get row for enabled fields with buttons
        //var fieldHolder = element.parent().parent().parent().parent().parent();
        var fieldHolder = element.parent().parent().parent().parent().parent();
    }

    //change id of the field to 0
    var fieldId = element.attr("id");
    var fieldIdOrig = fieldId;
    var fieldName = element.attr("name");
    //console.log("fieldId="+fieldId+", fieldName="+fieldName);

    var idArr = fieldId.split("_"+field+"_");
    var idValue = idArr[1].split("_")[0];
    //console.log("idValue="+idValue);

    //var regexId = new RegExp( field + '_' + idValue, 'g' );
    fieldId = fieldId.replace( field + '_' + idValue, field + '_' + index);

    //change name of the field to 0
    var nameArr = fieldName.split("["+field+"]");
    var nameValueStr = nameArr[1];
    var nameValueArr = nameValueStr.split("[");
    var nameValue = nameValueArr[1].split("]")[0];
    //console.log("nameValue="+nameValue);

    var strTofind = '[' + field + ']' + '[' + nameValue + ']';
    //console.log("strTofind="+strTofind);    //strTofind=[diffDisident][6]
    var strReplace = '[' + field + ']' + '['+index+']';
    //console.log("strReplace="+strReplace);

    fieldName = fieldName.replace(strTofind, strReplace);   //[diffDisident][0]

    //console.log("fieldId="+fieldId+", fieldName="+fieldName);

    element.attr('id',fieldId);
    element.attr('name',fieldName);

    //replace id of label
    var rows = fieldHolder.parent().find('.row').first();
    //console.log( "rows id=" + rows.attr("id") + ", class=" + rows.attr("class") );

    var rowLabel = rows.first().find($('label[for='+fieldIdOrig+']'));
    //console.log( "rowLabel id=" + rowLabel.attr("id") + ", class=" + rowLabel.attr("class") );

    //var textLabel = rows.first().find($('label[for='+fieldIdOrig+']')).text();
    //console.log( "textLabel=" + textLabel );

    rowLabel.attr('id',fieldId);
    rowLabel.attr('for',fieldId);

    return;
}

//clean fields in Element Block, except key field
//all: if set to "all" => clean all fields, including key field
function cleanFieldsInElementBlock( element, all, single ) {

    var parent = getButtonElementParent( element );

    cleanPatientNameSexAgeLockedFields(parent);

    setPaperDocuments(element,parent,null);

    //console.log("clean single=" + single);

    //console.log("clean parent.id=" + parent.attr('id'));
    //printF(parent,"clean => parent");

    var elements = parent.find(selectStr).not("*[id^='s2id_']");

    for (var i = 0; i < elements.length; i++) {

        var id = elements.eq(i).attr("id");
        var type = elements.eq(i).attr("type");
        var tagName = elements.eq(i).prop('tagName');
        var classs = elements.eq(i).attr('class');

        //console.log("\n\nClean Element id="+id+", classs="+classs+", type="+type+", tagName="+tagName);

        processInputGroupCheckboxFields(elements.eq(i),null,null,'clear');

        //don't process elements not belonging to this button
        if( fieldBelongsToButton( element, elements.eq(i) ) === false ) {
            //console.log("this field does not belong to clicked button");
            continue;
        }

        //don't process simple fields, these fileds don't have id because they are not part of form
        if( typeof id === 'undefined' ) {
            continue;
        }

        //don't process slide fields
        if( id && id.indexOf("_slide_") != -1 ) {
            continue;
        }
        //don't process fields not containing patient (message fields)
        if( id && id.indexOf("_patient_") == -1 ) {
            continue;
        }
        //don't process patient fields if the form was submitted by single form: click on accession,part,block delete button
        //if( single && id && id.indexOf("_procedure_") == -1 ) {
            //console.log("don't process patient fields if the form was submitted by single form");
            //continue;
        //}

        //console.log("clean id="+id+", type="+type+", tagName="+tagName);

        //don't clean key fields belonging to other block button
        if( elements.eq(i).hasClass('keyfield') || elements.eq(i).hasClass('accessiontype-combobox') || elements.eq(i).hasClass('mrntype-combobox') ) {
            var btnObj = new btnObject( element );

            //console.log("keyfield: elements.eq(i).attr('id')="+elements.eq(i).attr('id'));

            //check type
            if( btnObj.typeelement && btnObj.typeelement.attr('id').replace("s2id_","") == elements.eq(i).attr('id') ) {
                //console.log( "type length="+btnObj.typeelement.length );
                //printF(btnObj.typeelement," Clean type: ");
                //btnObj.typeelement.select2("val", 1 );
                var dataArr = new Array();
                dataArr['text'] = "";
                dataArr['keytype'] = 1;
                setKeyGroup( btnObj.typeelement, dataArr );
            }

            //check field
            //console.log("btn field id="+btnObj.element.attr('id'));
            //console.log("element field id="+elements.eq(i).attr('id'));
            if( btnObj.element && btnObj.element.attr('id') != elements.eq(i).attr('id') ) {
                //console.log("don't clean this field!");
                continue;
            }
        } else {
            //printF(elements.eq(i),"don't clean key fields belonging to other block button: ");
        }

        if( type == "file" ) {

            elements.eq(i).parent().find('a').remove();
            elements.eq(i).show();

        } else if( type == "text" || !type ) {

            //console.log("clean as text, all="+all);
            var clean = false;
            var idsArr = id.split("_");
            var field = idsArr[idsArr.length-fieldIndex];
            if( all == "all" ) {
                clean = true;
            } else {
                //check if the field is not key
                if( !isKey(elements.eq(i), field) ) {
                    clean = true;
                }
            }
            if( clean ) {
                //console.log("in array field=" + field );
                if( $.inArray(field, arrayFieldShow) == -1 ) {
                   //console.log("clean not as arrayFieldShow");

                    if( tagName == "DIV" && !elements.eq(i).hasClass('select2') ) {
                        //console.log("clean as radio");
                        processGroup( elements.eq(i), "", "ignoreDisable" );
                    } else if( elements.eq(i).hasClass('select2') || elements.eq(i).hasClass('ajax-combobox') ) {
                        //console.log("clean as regular select (not keyfield types), field="+field);
                        elements.eq(i).select2('data', null);
                    } else {
                        //console.log("clean as regular");
                        elements.eq(i).val(null);
                    }

                } else {
                    //console.log("clean as an arrayFieldShow");
                    cleanArrayField( elements.eq(i), field, single );
                }
            }

        }

    }
}