<?php
/**
 * Copyright (c) 2017 Cornell University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace App\OrderformBundle\Repository;

use App\OrderformBundle\Entity\DataQualityMrnAcc;
use App\OrderformBundle\Form\DataTransformer\AccessionTypeTransformer;
use App\OrderformBundle\Entity\Block;
use App\OrderformBundle\Entity\Accession;
use App\OrderformBundle\Util\SecurityUtil;
use App\UserdirectoryBundle\Util\UserSecurityUtil;

//use Doctrine\ORM\EntityManagerInterface;
//use Doctrine\ORM\EntityRepository;
//use Doctrine\ORM\Mapping\ClassMetadata;

/**
 * AccessionRepository
 * This class was generated by the Doctrine ORM.
 * Add your own custom repository methods below.
 */
class AccessionRepository extends ArrayFieldAbstractRepository {

    public function changeKeytype($entity) {

        $em = $this->_em;

        $key = $entity->obtainValidKeyField();

        if( !$key->getKeytype() || $key->getKeytype() == "" ) {
            //this can happen when accession is generated by a user on the form
            //throw new \Exception( 'Accession does not have a valid keytype. keytype=' . $key->getKeytype() );
            $keytype = $em->getRepository('AppOrderformBundle:AccessionType')->findOneByName("Auto-generated Accession Number");
            $key->setKeytype($keytype);
        }

        $newkeytypeid = $this->getCorrectKeytypeId($key->getKeytype()->getId());
        if( $key == "" || $newkeytypeid != $key->getKeytype()->getId() ) {
            $newkeytypeEntity = $em->getRepository('AppOrderformBundle:AccessionType')->findOneByName("Auto-generated Accession Number");
            $key->setKeytype($newkeytypeEntity);
        }

        //strip zeros and record original
        $originalKey = $key->getField();
        $key->setOriginal($originalKey);
        $stripedKey = ltrim((string)$originalKey, '0');
        $key->setField($stripedKey);

//        echo $entity;
//        echo "num of keys=".count($entity->obtainKeyField())."<br>";
//        echo "number=".$entity->obtainValidKeyField()."<br>";
//        echo "original=".$entity->obtainValidKeyField()->getOriginal()."<br>";
//        echo "keytype=".$entity->obtainValidKeyField()->getKeytype()."<br>";

        return $entity;
    }

    //if keytype is "Existing Auto-generated Accession Number", then get "Auto-generated Accession Number" object and return its id
    //return id of the correct AccessionType
    public function getCorrectKeytypeId($keytypeid,$user=null) {
        $em = $this->_em;

        if( is_numeric ( $keytypeid ) ) {
            $keytypeEntity = $em->getRepository('AppOrderformBundle:AccessionType')->findOneById($keytypeid);
        } else {
            //create a new AccessionType entity
            $accTypeTransformer = new AccessionTypeTransformer($em,$user);
            $keytypeEntity = $accTypeTransformer->createNew($keytypeid);
        }

        if( $keytypeEntity->getName()."" == "Existing Auto-generated Accession Number" ) {
            $keytypeEntity = $em->getRepository('AppOrderformBundle:AccessionType')->findOneByName("Auto-generated Accession Number");
        }
        return $keytypeEntity->getId();
    }

    public function getExtraEntityById( $extra ) {
        $em = $this->_em;
        return $em->getRepository('AppOrderformBundle:AccessionType')->findOneById($extra["keytype"]);
    }


    //process conflict if exists for accession number. Replace conflicting accession number by a new generated number.
    public function processDuplicationKeyField( $accession, $message ) {

        if( !($accession instanceof Accession) ) {
            //echo 'Provided entity is not Accession, entity:'.$accession;
            throw new \Exception( 'Provided entity is not Accession, entity:'.$accession );
        }

        //echo "Must be accession: ".$accession;

        $em = $this->_em;

        //process data quality
        $currentDataquality = null;

        //echo "dataquality count=".count($message->getDataqualityMrnAcc())."<br>";

        //loop through all conflicts to find out if this accession is conflicted
        //To determine if this accession has geberated conflict: 1) compare accession number/type and mrn number/type of dataquality and form
        foreach( $message->getDataqualityMrnAcc() as $dataquality) {

            $accessionConflict = false;
            $patientConflict = false;

            //check if this dataquality's patient is corresponds to accession patient
            $mrn = $dataquality->getMrn();
            $mrntype = $dataquality->getMrntype();
            //                       procedure   encounter     patient
            $validMrn = $accession->getParent()->getParent()->getParent()->obtainValidKeyfield();
            $accmrn = $validMrn->getField();
            $accmrntype = $validMrn->getKeytype();
            //echo "compare patient: (".$mrn .")==(". $accmrn .") && (". $mrntype .")==(". $accmrntype.")<br>";
            //echo "acc patient:". $accession->getParent()->getParent();

            if( $mrntype == "" || $accmrntype == "" ) {
                throw new \Exception( 'Conflicting MRN Type is not provided: mrntype=' . $mrntype . ", accmrntype=" .$accmrntype );
            }

            if( $mrn && $mrn != '' && $accmrn && $accmrn != '' ) {
                //valid values are not empty
            } else {
                //echo "skip!!! <br>";
                $message->removeDataqualityMrnAcc($dataquality);
                continue;   //remove and skip this dataquality
            }

            if( $mrn == $accmrn && trim((string)$mrntype) == trim((string)$accmrntype) ) {
                $patientConflict = true;   //was true?
                //echo "patientConflict=".$patientConflict."<br>";
                //break;
            }
            echo "patientConflict=".$patientConflict."<br>";

            $conflictAccessionNum = $dataquality->getAccession()."";
            $conflictAccessionType = $dataquality->getAccessiontype()."";
            $currentAccessionNum = $accession->obtainValidKeyfield();
            $currentAccessionType = $accession->obtainValidKeyfield()->getKeytype()."";

            if( $conflictAccessionType == "" ) {
                throw new \Exception( 'Conflicting Accession Type is not provided: ' . $conflictAccessionType );
            }

            //echo $currentAccessionNum."?=".$conflictAccessionNum.", newAccession=".$dataquality->getNewaccession()."<br>";
            //echo $currentAccessionType."?=".$conflictAccessionType."<br>";

            if( $currentAccessionNum == $conflictAccessionNum && $currentAccessionType == $conflictAccessionType ) { //only for match accessions and if this accession was not processed yet
                if( !$dataquality->getNewaccession() ) {
                    $accessionConflict = true;
                }
            }

            echo "accessionConflict=".$accessionConflict.", patientConflict=".$patientConflict."<br>";

            if( $accessionConflict && $patientConflict ) {
                $currentDataquality = $dataquality;
                break;
            }
        }

        ///////////////// check DB directly for conflict, just in case JS fails to catch conflict and message's Dataquality is empty ////////////////////
        $dbconflict = false;
        if( $currentDataquality == null ) {

            echo "check conflict in DB <br>";
            $accKey = $accession->obtainValidKeyfield();
            $accValue = $accKey->getField()."";
            $accKeytype = $accKey->getKeytype()->getId();

            $procedure = $accession->getParent();
            if( !$procedure ) {
                throw new \Exception( 'Accession does not belong to Procedure' );
            }

            $encounter = $procedure->getParent();
            if( !$encounter ) {
                throw new \Exception( 'Procedure does not belong to Patient' );
            }

            $patient = $encounter->getParent();
            if( !$patient ) {
                throw new \Exception( 'Encounter does not belong to Patient' );
            }

            $mrnKey = $patient->obtainValidKeyField();
            $mrnValue = $mrnKey->getField()."";
            $mrnKeytype = $mrnKey->getKeytype()->getId();

            if( !$accession->getInstitution() ) {
                //echo "message inst=".$message->getInstitution()."<br>";
                $accession->setInstitution($message->getInstitution());
            }
            $institutions = array($accession->getInstitution()->getId());
            //echo "mrnKeytype Id=".$mrnKeytype."<br>";

            if( $this->isDBConflictByAccession( $institutions, $accValue, $accKeytype, $mrnValue, $mrnKeytype  ) ) {
                echo "DB conflict!<br>";
                $dbconflict = true;

                $currentDataquality = new DataQualityMrnAcc();

                //set mrntype
                $mrntype = $em->getRepository('AppOrderformBundle:MrnType')->findOneById( $mrnKeytype );
                $currentDataquality->setMrntype($mrntype);
                $currentDataquality->setMrn($mrnValue);

                //set accessiontype
                $accessiontype = $em->getRepository('AppOrderformBundle:AccessionType')->findOneById( $accKeytype );
                $currentDataquality->setAccessiontype($accessiontype);
                $currentDataquality->setAccession($accValue);

                $currentDataquality->setMessage($message);
                $currentDataquality->setProvider($message->getProvider());
                $currentDataquality->setStatus('active');

                $message->addDataqualityMrnAcc($currentDataquality);

            }
        }
        ///////////////// EOF check DB directly for conflict, just in case JS fails to catch conflict and message's Dataquality is empty ////////////////////

        if( $currentDataquality == null && $dbconflict == false ) {
            //echo "#####this is not conflict accession => return !!!!!! <br>";
            return $accession;
        }

        //Now we know that this accession has MRN conflict
        echo "Now we know that this accession has MRN conflict <br>";

        //1) take care of mrn-accession conflict: replace accession# with NOACCESSIONIDPROVIDED:
        $accession->setId(null); //make sure to generate a new accession
        $accession->setStatusAllKeyfield(self::STATUS_INVALID);
        $accession->createKeyField();

        $acctype = $em->getRepository('AppOrderformBundle:AccessionType')->findOneByName("Auto-generated Accession Number");

        $securityUtil = new UserSecurityUtil($this->_em);
        $source = $securityUtil->getDefaultSourceSystem();

        //we should have only one key field !!!
        $key = $accession->obtainValidKeyField();
        $key->setKeytype($acctype);
        $key->setStatus(self::STATUS_VALID);
        $key->setSource($source);
        $key->setProvider($message->getProvider());

        if( !$accession->getInstitution() ) {
            $accession->setInstitution($message->getInstitution());
        }

        $nextKey = $this->getNextNonProvided($accession,null,$message);
        $key->setField($nextKey);

        //set new accession number to dataquality
        $currentDataquality->setNewaccession($nextKey);
        $currentDataquality->setNewaccessiontype($acctype);

        if( $dbconflict ) {
            $desc = "MRN-Accession conflict detected in submit logic. Submitted values are ".
            "Accession Number: ".$accValue.", Accession Type: ".$accKeytype.", MRN: ".$mrnValue.", MRN Type: ".$mrnKeytype."\n" .
            "Conflict was resolved by generating new Accession with Accession Number:".$nextKey.", Accession Type:".$acctype;
            $currentDataquality->setDescription($desc);
        }

        //echo "<br>-----------------Original Accession:<br>";
        //$this->printTree( $accession );
        //echo "--------------------------<br>";
        //echo "finish process Accession: ".$accession."<br>";

        return $accession;

    }

    //check if there is a conflict in DB
    public function isDBConflictByAccession( $institutions, $accValue, $accKeytype, $mrnValue, $mrnKeytype ) {

        if( !$accValue || $accValue == "" || !$accKeytype || $accKeytype == "" || !$mrnValue || $mrnValue == "" || !$mrnKeytype || $mrnKeytype == "" ) {
            return false;
        }

        $extra = array();
        $extra["keytype"] = $accKeytype;

        $validity = array();
        $validity[] = self::STATUS_VALID;
        //$validity[] = self::STATUS_RESERVED;

        $accessions = $this->_em->getRepository('AppOrderformBundle:Accession')->findOneByIdJoinedToField(
            $institutions,
            $accValue,      //$fieldStr
            "Accession",    //$className
            "accession",    //$fieldName
            $validity,      //$validity
            false,           //$single
            $extra          //$extra
        );

        //echo "accessions count=".count($accessions)."<br>";

        //foreach( $accessions as $acc ){
        //    echo $acc;
        //}

        if( count($accessions) > 1 ) {
            //throw new \Exception( 'More than one Accession found, but single entity is expected:  key='. $accValue. ', type=' . $accKeytype . ', found=' . count($accessions) );
            //TODO: for now use the first accession. Make sure only one unique accession is created
        }

        if( count($accessions) == 0 ) {
            return false;   //Accession does not exist in DB => no conflict
        }

        $accession = $accessions[0];

        $procedure = $accession->getParent();
        if( !$procedure ) {
            return false;
        }

        //                     encounter     patient
        $patient = $procedure->getParent()->getParent();
        if( !$patient ) {
            return false;
        }

        $mrnKey = $patient->obtainValidKeyField();
        $mrnValueDb = $mrnKey->getField()."";
        $mrnKeytypeDb = $mrnKey->getKeytype()->getId();

        //echo "compare found accession's mrn: mrnValueDb:".$mrnValueDb." == mrnValue:".$mrnValue." && mrnKeytypeDb:".$mrnKeytypeDb." == mrnKeytype:".$mrnKeytype."<br>";

        if( $mrnValueDb == $mrnValue && $mrnKeytypeDb == $mrnKeytype ) {
            return false;
        } else {
            return true;
        }

        return false;
    }


    public function setCorrectAccessionIfConflict( $slide, $message ) {

        $slideParent = $slide->getParent();

        $class = new \ReflectionClass($slideParent);
        $className = $class->getShortName();

        if( $slideParent instanceof Block ) {
                        //    block     part        accession
            $accession = $slideParent->getParent()->getParent();
        } else {
                        //    part      accession
            $accession = $slideParent->getParent();
        }

        $accession = $this->processDuplicationKeyField( $accession, $message );


    }


    public function findByAccessiontypeString($typeStr) {
        $query = $this->_em->createQueryBuilder()
            ->from('AppOrderformBundle:Accession', 'entity')
            ->select("entity")
            ->leftJoin("entity.accession", "accession")
            ->leftJoin("accession.keytype", "keytype")
            ->where("keytype.name = :keytypeStr")
            ->setParameters( array('keytypeStr'=>$typeStr) )
            ->getQuery();

        $accessions = $query->getResult();
        //echo "accession count=".count($accessions)." ";

        return $accessions;
    }


}
?>
